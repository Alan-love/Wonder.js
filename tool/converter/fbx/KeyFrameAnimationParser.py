from fbx import *
from helper import *

class KeyFrameAnimationParser(object):
    def __init__(self, output):
        self._output = output
        self._animationName = None
        # self._globalSetting = None

    def parse(self, scene):
        animationDatas = {}
        self._output["animations"] = animationDatas

        # self._globalSetting = scene.GetGlobalSettings()

        for i in range(scene.GetSrcObjectCount(FbxCriteria.ObjectType(FbxAnimStack.ClassId))):
            animStack = scene.GetSrcObject(FbxCriteria.ObjectType(FbxAnimStack.ClassId), i)

            self._animStack = animStack

            animationData = {}

            self._animationName = getAnimationId(animStack)
            animationDatas[self._animationName] = animationData


            self._parseLayers(animStack, scene.GetRootNode(), animationData)
            # DisplayAnimation(lAnimStack, pScene->GetRootNode(), true);

        self._removeEmptyAnimationData()

    def _removeEmptyAnimationData(self):
        animations = self._output["animations"]

        for key, data in animations.items():
            if not data.has_key("channels"):
                del animations[key]

    def _parseLayers(self, animStack, rootNode, animationData):
        animLayerCount = animStack.GetMemberCount(FbxCriteria.ObjectType(FbxAnimLayer .ClassId))

        print ("animLayerCount %d " % animLayerCount)

        # TODO should only support one layer?(not support blend yet)
        for i in range(animLayerCount):
            layer = animStack.GetMember(FbxCriteria.ObjectType(FbxAnimLayer .ClassId), i)

            self._parseLayer(layer, rootNode, animationData)

    def _parseLayer(self, animLayer, node, animationData):
        self._parseAnimationData(node, animLayer, animationData)

        for i in range(node.GetChildCount()):
            self._parseLayer(animLayer, node.GetChild(i), animationData)

    def _parseAnimationData(self, node, animLayer, animationData):
        # animationData["channels"] =

        print ("parse %s ", node.GetName())

        self._parseLocalTranslationData(animLayer, node, animationData)
        self._parseLocalRotationData(animLayer, node, animationData)
        self._parseLocalScaleData(animLayer, node, animationData)

    def _parseLocalTranslationData(self, animLayer, node, animationData):
        curveX = node.LclTranslation.GetCurve(animLayer, "X")
        curveY = node.LclTranslation.GetCurve(animLayer, "Y")
        curveZ = node.LclTranslation.GetCurve(animLayer, "Z")

        self._parseTransformData("translation", animLayer, node, animationData, curveX, curveY, curveZ)

    def _parseTransformData(self, path, animLayer, node, animationData, curveX, curveY, curveZ):

        if not self._isCurveHasData(curveX) and not self._isCurveHasData(curveY) and not self._isCurveHasData(curveZ):
            return

        # TODO fix!
        if (self._isCurveHasData(curveX) and self._isCurveHasData(curveY) and curveX.KeyGetCount() != curveY.KeyGetCount())\
                or (self._isCurveHasData(curveX) and self._isCurveHasData(curveZ) and curveX.KeyGetCount() != curveZ.KeyGetCount()) \
                or (self._isCurveHasData(curveY) and self._isCurveHasData(curveZ) and curveY.KeyGetCount() != curveZ.KeyGetCount()):
            if self._isCurveHasData(curveX):
                print ("curveX key count:%d" % curveX.KeyGetCount())
            if self._isCurveHasData(curveY):
                print ("curveY key count:%d" % curveY.KeyGetCount())
            if self._isCurveHasData(curveZ):
                print ("curveZ key count:%d" % curveZ.KeyGetCount())
            print ("error curve data:the %s curve data components' count are different with node:%s" % (path, getName(node)))
            return


        curveWhichHasData = None

        if self._isCurveHasData(curveX):
            curveWhichHasData = curveX
        elif self._isCurveHasData(curveY):
            curveWhichHasData = curveY
        else:
            curveWhichHasData = curveZ

        # has no data(test with the fbx file generated by blender)
        if curveWhichHasData.KeyGetCount() <= 2:
            return

        self._parseData(animationData, getObjectId(node), path, curveWhichHasData, curveX, curveY, curveZ)

    def _isCurveHasData(self, curve):
        return curve and curve.KeyGetCount() > 1

    def _parseLocalRotationData(self, animLayer, node, animationData):
        curveX = node.LclRotation.GetCurve(animLayer, "X")
        curveY = node.LclRotation.GetCurve(animLayer, "Y")
        curveZ = node.LclRotation.GetCurve(animLayer, "Z")


        self._parseTransformData("rotation", animLayer, node, animationData, curveX, curveY, curveZ)

        # # if curveX and curveY and curveZ:
        # #     if curveX.KeyGetCount() != curveY.KeyGetCount() or curveX.KeyGetCount() != curveZ.KeyGetCount():
        # #         # print (curveX.KeyGetCount(), curveY.KeyGetCount(), curveZ.KeyGetCount())
        # #         print ("error curve data:the rotation curve data components' count are different with node:%s" % getName(node))
        # #         return
        # #
        # #     print ("has curve rotation")
        # self._parseData(animationData, getObjectId(node), "rotation", curveWhichHasData, curveX, curveY, curveZ)

    def _parseLocalScaleData(self, animLayer, node, animationData):
        curveX = node.LclScaling.GetCurve(animLayer, "X")
        curveY = node.LclScaling.GetCurve(animLayer, "Y")
        curveZ = node.LclScaling.GetCurve(animLayer, "Z")

        self._parseTransformData("scale", animLayer, node, animationData, curveX, curveY, curveZ)
        # if curveX and curveY and curveZ:
        #     if curveX.KeyGetCount() != curveY.KeyGetCount() or curveX.KeyGetCount() != curveZ.KeyGetCount():
        #         print ("error curve data:the scale curve data components' count are different with node:%s" % getName(node))
        #         return
        #
        #     # print ("has curve")
        #     self._parseData(animationData, getObjectId(node), "scale", curveX.KeyGetCount(), curveX, curveY, curveZ)


    def _parseData(self, animationData, nodeId, path, curveWhichHasData, curveX, curveY, curveZ):
        # TODO not support Constant interpolation?
        interpolation = self._parseInterpolation(curveWhichHasData)
        timeList = []
        valueList = []

        keyCount = curveWhichHasData.KeyGetCount()

        # print (dir(self._globalSetting))
        # animStack->GetLocalTimeSpan().GetStart()
        # print (animStack->GetLocalTimeSpan().GetStart())
        # print (self._globalSetting.GetCurrent)
        # print (self._globalSetting.AnimationsFrameRate())
        # print (self._animStack.GetLocalTimeSpan().GetStart().GetFrameCount())
        print (self._animStack.GetLocalTimeSpan().GetStart().GetMilliSeconds())
        print (self._animStack.GetLocalTimeSpan().GetStop().GetMilliSeconds())



        # print (self._animStack.GetLocalTimeSpan().GetStop().GetFrameCount())
        # animTimeMode = self._globalSetting.Current().AnimationsTimeMode

        # print (animTimeMode)

        # print ("curve key count %d" % keyCount)
        for i in range(keyCount):
            # if curveX.KeyGetTime(i).GetMilliSeconds() != curveY.KeyGetTime(i).GetMilliSeconds() or curveX.KeyGetTime(i).GetMilliSeconds() != curveZ.KeyGetTime(i).GetMilliSeconds():
            #     raise AssertionError("the time of different components of curve data should be the same")

            if (self._isCurveHasData(curveX) and self._isCurveHasData(curveY) and curveX.KeyGetTime(i).GetMilliSeconds() != curveY.KeyGetTime(i).GetMilliSeconds()) \
                    or (self._isCurveHasData(curveX) and self._isCurveHasData(curveZ) and curveX.KeyGetTime(i).GetMilliSeconds() != curveZ.KeyGetTime(i).GetMilliSeconds()) \
                    or (self._isCurveHasData(curveY) and self._isCurveHasData(curveZ) and curveY.KeyGetTime(i).GetMilliSeconds() != curveZ.KeyGetTime(i).GetMilliSeconds()):
                raise AssertionError("the time of different components of curve data should be the same")

            timeList.append(curveWhichHasData.KeyGetTime(i).GetMilliSeconds())
            # print(curveWhichHasData.KeyGetTime(i).GetTimeString("", FbxUShort(256)))

            if self._isCurveHasData(curveX):
                valueList.append(curveX.KeyGetValue(i))
            else:
                valueList.append(0)

            if self._isCurveHasData(curveY):
                valueList.append(curveY.KeyGetValue(i))
            else:
                valueList.append(0)

            if self._isCurveHasData(curveZ):
                valueList.append(curveZ.KeyGetValue(i))
            else:
                valueList.append(0)

        self._addData(animationData, nodeId, path, interpolation, timeList, valueList)

    def _parseInterpolation(self, curveWhichHasData):
        # if curveX.KeyGetInterpolation(0) != curveY.KeyGetInterpolation(0) or curveX.KeyGetInterpolation(0) != curveZ.KeyGetInterpolation(0):
        #     raise AssertionError("the interpolation of one of animation->channels should be the same")

        interpolation = curveWhichHasData.KeyGetInterpolation(0)

        if interpolation == FbxAnimCurveDef.eInterpolationConstant:
            return "CONSTANT"
        elif interpolation == FbxAnimCurveDef.eInterpolationLinear:
            return "LINEAR"
        elif interpolation == FbxAnimCurveDef.eInterpolationCubic:
            return "CUBIC"
        else:
            raise AssertionError("unknow interpolation:%d" % interpolation)

    def _addData(self, animationData, nodeId, path, interpolation, timeList, valueList):
        channels = None

        if not animationData.has_key("channels"):
            channels = []
            animationData["channels"] = channels
        else:
            channels = animationData["channels"]

        samplerId = self._getSamplerId(path)

        channels.append({
            "sampler": samplerId,
            "target": {
                "id": nodeId,
                "path": path
            }
        })

        if not animationData.has_key("parameters"):
            animationData["parameters"] = {}

        if not animationData.has_key("samplers"):
            animationData["samplers"] = {}

        if not animationData["parameters"].has_key("TIME"):
            animationData["parameters"]["TIME"] = timeList
        else:
            # TODO asset time data should be equal
            print (len(timeList))
            pass

        if animationData["parameters"].has_key(path):
            raise AssertionError("parameters->%s shouldn't be defined before" % path)

        animationData["parameters"][path] = valueList

        if animationData["samplers"].has_key(samplerId):
            raise AssertionError("samplers->%s shouldn't be defined before" % samplerId)

        animationData["samplers"][samplerId] = {
            "input": "TIME",
            "interpolation": interpolation,
            "output": path
        }

    def _getSamplerId(self, path):
        return "%s_%s_sampler" % (self._animationName, path)
