// Generated by dts-bundle v0.7.2

declare module 'wonder-fantasy-land/dist/es2015' {
    export { Either, Right, Left } from "wonder-fantasy-land/dist/es2015/types/Either";
    export { IO } from "wonder-fantasy-land/dist/es2015/types/IO";
    export { Maybe, Just, Nothing } from "wonder-fantasy-land/dist/es2015/types/Maybe";
}

declare module 'wonder-fantasy-land/dist/es2015/types/Either' {
    export abstract class Either {
        val: any;
        constructor(x: any);
        abstract map(f: (x: any) => any): Either;
        abstract chain(f: (x: any) => Either): Either;
        either<T, R>(leftFn: (x: any) => T, rightFn: (x: any) => R): T | R;
    }
    export class Right extends Either {
        static of(x: any): Right;
        isRight(): boolean;
        isLeft(): boolean;
        map(f: (x: any) => any): Right;
        ap(that: Either): Either;
        chain(f: (x: any) => Either): Either;
        toString(): string;
    }
    export class Left extends Either {
        static of(x: any): Left;
        isRight(): boolean;
        isLeft(): boolean;
        map(f: (x: any) => any): this;
        ap(that: Either): this;
        chain(f: (x: any) => Either): this;
        toString(): string;
    }
}

declare module 'wonder-fantasy-land/dist/es2015/types/IO' {
    export class IO {
        static of(func: Function): IO;
        func: Function;
        constructor(func: Function);
        chain(f: (...args) => IO): IO;
        map(f: Function): IO;
        ap(thatIO: IO): IO;
        run(...args: any[]): any;
        toString(): string;
    }
}

declare module 'wonder-fantasy-land/dist/es2015/types/Maybe' {
    export abstract class Maybe {
        static of(x: any): Just;
        static maybe(x: any, f: (x: any) => any, m: Maybe): void;
        static Just(x: any): Just;
        static Nothing(): Nothing;
        static isJust(x: Maybe): boolean;
        static isNothing(x: Maybe): boolean;
        val: any;
        abstract map(f: (x: any) => any): Maybe;
        abstract ap(m: Maybe): Maybe;
        abstract chain(f: (x: any) => Maybe): any;
        toString(): string;
        isNothing(): boolean;
        isJust(): boolean;
    }
    export class Just extends Maybe {
        constructor(x: any);
        isJust(): boolean;
        isNothing(): boolean;
        map(f: (x: any) => any): Just;
        chain(f: (x: any) => Maybe): Maybe;
        ap(m: Maybe): Maybe;
        toString(): string;
    }
    export class Nothing extends Maybe {
        isJust(): boolean;
        isNothing(): boolean;
        map(f: (x: any) => any): this;
        chain(f: (x: any) => Maybe): this;
        ap(m: Maybe): this;
        toString(): string;
    }
}

