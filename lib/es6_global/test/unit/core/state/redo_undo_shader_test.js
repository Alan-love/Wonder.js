// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Curry                           from "../../../../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Sinon                           from "../../../../../../node_modules/wonder-bs-sinon/lib/es6_global/src/sinon.js";
import * as Sinon$1                         from "sinon";
import * as Wonder_jest                     from "../../../../../../node_modules/wonder-bs-jest/lib/es6_global/src/wonder_jest.js";
import * as TestTool$Wonderjs               from "../../tool/TestTool.js";
import * as StateTool$Wonderjs              from "../../tool/core/StateTool.js";
import * as FakeGlTool$Wonderjs             from "../../tool/gl/FakeGlTool.js";
import * as GameObject$Wonderjs             from "../../../../src/ecs/admin/api/GameObject.js";
import * as ShaderTool$Wonderjs             from "../../tool/render/shader/ShaderTool.js";
import * as ProgramTool$Wonderjs            from "../../tool/render/shader/ProgramTool.js";
import * as DirectorTool$Wonderjs           from "../../tool/core/DirectorTool.js";
import * as BasicMaterial$Wonderjs          from "../../../../src/ecs/component/api/material/BasicMaterial.js";
import * as HashMapSystem$Wonderjs          from "../../../../src/structure/HashMapSystem.js";
import * as GLSLSenderTool$Wonderjs         from "../../tool/render/shader/GLSLSenderTool.js";
import * as GameObjectTool$Wonderjs         from "../../tool/core/GameObjectTool.js";
import * as SourceInstance$Wonderjs         from "../../../../src/ecs/component/api/instance/SourceInstance.js";
import * as BoxGeometryTool$Wonderjs        from "../../tool/component/geometry/BoxGeometryTool.js";
import * as SparseMapSystem$Wonderjs        from "../../../../src/structure/SparseMapSystem.js";
import * as GLSLLocationTool$Wonderjs       from "../../tool/render/shader/GLSLLocationTool.js";
import * as ArraySystem$WonderCommonlib     from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArraySystem.js";
import * as HashMapSystem$WonderCommonlib   from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/HashMapSystem.js";
import * as SparseMapSystem$WonderCommonlib from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapSystem.js";

describe("test redo,undo shader data", (function () {
        var sandbox = Sinon.getSandboxDefaultVal(/* () */0);
        var state = [StateTool$Wonderjs.createState(/* None */0, /* () */0)];
        var _prepareGLSLSenderData = function (state) {
          var match = GLSLSenderTool$Wonderjs.getGLSLSenderData(state);
          var vertexAttribHistoryArray = match[/* vertexAttribHistoryArray */7];
          SparseMapSystem$WonderCommonlib.set(0, 0, match[/* attributeSendDataMap */0]);
          SparseMapSystem$WonderCommonlib.set(0, 2, vertexAttribHistoryArray);
          return /* tuple */[
                  state,
                  0,
                  0,
                  1,
                  2
                ];
        };
        var _prepareShaderData = function (state) {
          var data = ShaderTool$Wonderjs.getShaderData(state);
          data[/* index */0] = 2;
          HashMapSystem$WonderCommonlib.set("key1", 0, data[/* shaderIndexMap */1]);
          HashMapSystem$WonderCommonlib.set("key2", 1, data[/* shaderIndexMap */1]);
          return /* tuple */[
                  state,
                  0,
                  1
                ];
        };
        var _prepareProgramData = function (state) {
          var data = ProgramTool$Wonderjs.getProgramData(state);
          SparseMapSystem$WonderCommonlib.set(0, 11, data[/* programMap */0]);
          data[/* lastUsedProgram */1] = 11;
          return /* tuple */[
                  state,
                  0,
                  11
                ];
        };
        beforeEach((function () {
                sandbox[0] = Sinon$1.sandbox.create();
                state[0] = TestTool$Wonderjs.init(sandbox, /* None */0, /* None */0, /* () */0);
                return /* () */0;
              }));
        afterEach((function () {
                return Curry._1(Sinon.restoreSandbox, sandbox[0]);
              }));
        describe("restore", (function () {
                describe("restore glsl sender data to target state", (function () {
                        Wonder_jest.test("clean last send data", (function () {
                                var match = _prepareGLSLSenderData(state[0]);
                                var match$1 = _prepareGLSLSenderData(StateTool$Wonderjs.createNewCompleteState(/* () */0));
                                var newState = StateTool$Wonderjs.restore(match$1[0], match[0]);
                                var match$2 = GLSLSenderTool$Wonderjs.getGLSLSenderData(newState);
                                var lastSendArrayBuffer = match$2[/* lastSendArrayBuffer */8];
                                var lastSendElementArrayBuffer = match$2[/* lastSendElementArrayBuffer */9];
                                var lastSendMaterial = match$2[/* lastSendMaterial */10];
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                lastSendArrayBuffer,
                                                lastSendElementArrayBuffer,
                                                lastSendMaterial
                                              ]), /* tuple */[
                                            /* None */0,
                                            /* None */0,
                                            /* None */0
                                          ]);
                              }));
                        return Wonder_jest.test("clean vertexAttribHistoryArray", (function () {
                                      var match = _prepareGLSLSenderData(state[0]);
                                      var match$1 = _prepareGLSLSenderData(StateTool$Wonderjs.createNewCompleteState(/* () */0));
                                      var newState = StateTool$Wonderjs.restore(match$1[0], match[0]);
                                      var match$2 = GLSLSenderTool$Wonderjs.getGLSLSenderData(newState);
                                      var vertexAttribHistoryArray = match$2[/* vertexAttribHistoryArray */7];
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](vertexAttribHistoryArray), ArraySystem$WonderCommonlib.createEmpty(/* () */0));
                                    }));
                      }));
                describe("restore shader data to target state", (function () {
                        describe("contract check", (function () {
                                return Wonder_jest.test("currentState and targetState ->shaderData->glslData->precision should be the same", (function () {
                                              var match = _prepareShaderData(state[0]);
                                              var state$1 = match[0];
                                              var currentState = StateTool$Wonderjs.createNewCompleteState(/* () */0);
                                              TestTool$Wonderjs.openContractCheck(/* () */0);
                                              var data = ShaderTool$Wonderjs.getShaderData(currentState);
                                              data[/* glslData */2][/* precision */0] = /* Some */["aaa"];
                                              return Wonder_jest.Expect[/* toThrowMessage */20]("currentState and targetState ->shaderData->glslData->precision should be the same", Wonder_jest.Expect[/* expect */0]((function () {
                                                                StateTool$Wonderjs.restore(currentState, state$1);
                                                                return /* () */0;
                                                              })));
                                            }));
                              }));
                        return /* () */0;
                      }));
                describe("restore program data to target state", (function () {
                        return Wonder_jest.test("clean lastUsedProgram", (function () {
                                      var match = _prepareProgramData(state[0]);
                                      var match$1 = _prepareProgramData(StateTool$Wonderjs.createNewCompleteState(/* () */0));
                                      var newState = StateTool$Wonderjs.restore(match$1[0], match[0]);
                                      var match$2 = ProgramTool$Wonderjs.getProgramData(newState);
                                      var lastUsedProgram = match$2[/* lastUsedProgram */1];
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](lastUsedProgram), /* None */0);
                                    }));
                      }));
                describe("restore gpu shader related data to target state", (function () {
                        describe("test init shader", (function () {
                                var _prepareBasicMaterialGameObject = function (_, state) {
                                  var match = BasicMaterial$Wonderjs.createBasicMaterial(state);
                                  var match$1 = BoxGeometryTool$Wonderjs.createBoxGeometry(match[0]);
                                  var match$2 = GameObject$Wonderjs.createGameObject(match$1[0]);
                                  var gameObject = match$2[1];
                                  var state$1 = GameObject$Wonderjs.addGameObjectGeometryComponent(gameObject, match$1[1], GameObject$Wonderjs.addGameObjectMaterialComponent(gameObject, match[1], match$2[0]));
                                  return /* tuple */[
                                          state$1,
                                          gameObject
                                        ];
                                };
                                var _prepareInstanceGameObject = function (_, state) {
                                  var match = BasicMaterial$Wonderjs.createBasicMaterial(state);
                                  var match$1 = BoxGeometryTool$Wonderjs.createBoxGeometry(match[0]);
                                  var match$2 = GameObject$Wonderjs.createGameObject(match$1[0]);
                                  var gameObject = match$2[1];
                                  var match$3 = SourceInstance$Wonderjs.createSourceInstance(match$2[0]);
                                  var state$1 = GameObject$Wonderjs.addGameObjectGeometryComponent(gameObject, match$1[1], GameObject$Wonderjs.addGameObjectMaterialComponent(gameObject, match[1], GameObject$Wonderjs.addGameObjectSourceInstanceComponent(gameObject, match$3[1], match$3[0])));
                                  return /* tuple */[
                                          state$1,
                                          gameObject
                                        ];
                                };
                                var _exec = function (currentState, copiedState, gameObject) {
                                  var currentStateCreateProgram = Sinon.createEmptyStubWithJsObjSandbox(sandbox);
                                  var currentState$1 = FakeGlTool$Wonderjs.setFakeGl(FakeGlTool$Wonderjs.buildFakeGl(sandbox, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[currentStateCreateProgram], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* () */0), currentState);
                                  var currentState$2 = GameObjectTool$Wonderjs.initGameObject(gameObject, currentState$1);
                                  var initShaderCount = Sinon.getCallCount(currentStateCreateProgram);
                                  StateTool$Wonderjs.restore(currentState$2, copiedState);
                                  return /* tuple */[
                                          currentStateCreateProgram,
                                          initShaderCount
                                        ];
                                };
                                Wonder_jest.test("if targetState->shader not exist in currentState->shader, init it", (function () {
                                        var match = _prepareInstanceGameObject(sandbox, state[0]);
                                        var state$1 = FakeGlTool$Wonderjs.setFakeGl(FakeGlTool$Wonderjs.buildFakeGl(sandbox, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* () */0), match[0]);
                                        var state$2 = DirectorTool$Wonderjs.init(DirectorTool$Wonderjs.prepare(state$1));
                                        var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$2);
                                        var currentState = StateTool$Wonderjs.createNewCompleteState(/* () */0);
                                        var match$1 = _prepareBasicMaterialGameObject(sandbox, currentState);
                                        var match$2 = _exec(match$1[0], copiedState, match$1[1]);
                                        return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](Sinon.getCallCount(match$2[0])), match$2[1] + 1 | 0);
                                      }));
                                describe("else, not init it", (function () {
                                        Wonder_jest.test("test", (function () {
                                                var match = _prepareInstanceGameObject(sandbox, state[0]);
                                                var match$1 = _prepareBasicMaterialGameObject(sandbox, match[0]);
                                                var state$1 = FakeGlTool$Wonderjs.setFakeGl(FakeGlTool$Wonderjs.buildFakeGl(sandbox, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* () */0), match$1[0]);
                                                var state$2 = DirectorTool$Wonderjs.init(DirectorTool$Wonderjs.prepare(state$1));
                                                var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$2);
                                                var currentState = StateTool$Wonderjs.createNewCompleteState(/* () */0);
                                                var match$2 = _prepareBasicMaterialGameObject(sandbox, currentState);
                                                var match$3 = _exec(match$2[0], copiedState, match$2[1]);
                                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](Sinon.getCallCount(match$3[0])), match$3[1] + 1 | 0);
                                              }));
                                        describe("fix bug", (function () {
                                                return Wonder_jest.test("test create gameObject which has no material", (function () {
                                                              var match = _prepareInstanceGameObject(sandbox, state[0]);
                                                              var match$1 = GameObjectTool$Wonderjs.createGameObject(match[0]);
                                                              var match$2 = _prepareBasicMaterialGameObject(sandbox, match$1[0]);
                                                              var state$1 = FakeGlTool$Wonderjs.setFakeGl(FakeGlTool$Wonderjs.buildFakeGl(sandbox, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* () */0), match$2[0]);
                                                              var state$2 = DirectorTool$Wonderjs.init(DirectorTool$Wonderjs.prepare(state$1));
                                                              var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$2);
                                                              var match$3 = _prepareBasicMaterialGameObject(sandbox, state$2);
                                                              var match$4 = _exec(match$3[0], copiedState, match$3[1]);
                                                              return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](Sinon.getCallCount(match$4[0])), match$4[1]);
                                                            }));
                                              }));
                                        return /* () */0;
                                      }));
                                return /* () */0;
                              }));
                        describe("test restore data", (function () {
                                var _prepareState1 = function (state) {
                                  var data = ShaderTool$Wonderjs.getShaderData(state);
                                  var shaderIndexMap = data[/* shaderIndexMap */1];
                                  data[/* index */0] = 3;
                                  HashMapSystem$WonderCommonlib.set("key3", 2, HashMapSystem$WonderCommonlib.set("key2", 1, HashMapSystem$WonderCommonlib.set("key1", 0, shaderIndexMap)));
                                  var data$1 = ProgramTool$Wonderjs.getProgramData(state);
                                  SparseMapSystem$WonderCommonlib.set(1, 12, SparseMapSystem$WonderCommonlib.set(0, 11, data$1[/* programMap */0]));
                                  data$1[/* lastUsedProgram */1] = 12;
                                  var match = GLSLLocationTool$Wonderjs.getGLSLLocationData(state);
                                  SparseMapSystem$WonderCommonlib.set(1, 22, SparseMapSystem$WonderCommonlib.set(0, 21, match[/* attributeLocationMap */0]));
                                  SparseMapSystem$WonderCommonlib.set(1, 32, SparseMapSystem$WonderCommonlib.set(0, 31, match[/* uniformLocationMap */1]));
                                  var match$1 = GLSLSenderTool$Wonderjs.getGLSLSenderData(state);
                                  SparseMapSystem$WonderCommonlib.set(1, 122, SparseMapSystem$WonderCommonlib.set(0, 121, match$1[/* shaderUniformSendNoCacheableDataMap */5]));
                                  return /* tuple */[
                                          state,
                                          /* tuple */[
                                            0,
                                            1
                                          ],
                                          /* tuple */[
                                            11,
                                            12
                                          ],
                                          /* tuple */[
                                            21,
                                            22,
                                            31,
                                            32
                                          ],
                                          /* tuple */[
                                            121,
                                            122
                                          ]
                                        ];
                                };
                                var _prepareState2 = function (state) {
                                  var data = ShaderTool$Wonderjs.getShaderData(state);
                                  var shaderIndexMap = data[/* shaderIndexMap */1];
                                  data[/* index */0] = 2;
                                  HashMapSystem$WonderCommonlib.set("key4", 4, HashMapSystem$WonderCommonlib.set("key1", 3, shaderIndexMap));
                                  var data$1 = ProgramTool$Wonderjs.getProgramData(state);
                                  SparseMapSystem$WonderCommonlib.set(4, 102, SparseMapSystem$WonderCommonlib.set(3, 101, data$1[/* programMap */0]));
                                  data$1[/* lastUsedProgram */1] = 102;
                                  var match = GLSLLocationTool$Wonderjs.getGLSLLocationData(state);
                                  SparseMapSystem$WonderCommonlib.set(4, 202, SparseMapSystem$WonderCommonlib.set(3, 201, match[/* attributeLocationMap */0]));
                                  SparseMapSystem$WonderCommonlib.set(4, 302, SparseMapSystem$WonderCommonlib.set(3, 301, match[/* uniformLocationMap */1]));
                                  var match$1 = GLSLSenderTool$Wonderjs.getGLSLSenderData(state);
                                  SparseMapSystem$WonderCommonlib.set(4, 10222, SparseMapSystem$WonderCommonlib.set(3, 10221, match$1[/* shaderUniformSendNoCacheableDataMap */5]));
                                  return /* tuple */[
                                          state,
                                          /* tuple */[
                                            3,
                                            4
                                          ],
                                          /* tuple */[
                                            101,
                                            102
                                          ],
                                          /* tuple */[
                                            201,
                                            202,
                                            301,
                                            302
                                          ],
                                          /* tuple */[
                                            10221,
                                            10222
                                          ]
                                        ];
                                };
                                var _prepare = function (state) {
                                  var match = _prepareState1(state);
                                  var targetState = match[0];
                                  var match$1 = _prepareState2(StateTool$Wonderjs.createNewCompleteState(/* () */0));
                                  var currentState = match$1[0];
                                  var newState = StateTool$Wonderjs.restore(currentState, targetState);
                                  return /* tuple */[
                                          newState,
                                          /* tuple */[
                                            currentState,
                                            match$1[1],
                                            match$1[2],
                                            match$1[3],
                                            match$1[4]
                                          ],
                                          /* tuple */[
                                            targetState,
                                            match[1],
                                            match[2],
                                            match[3],
                                            match[4]
                                          ]
                                        ];
                                };
                                describe("test restore shader data", (function () {
                                        describe("test index", (function () {
                                                return Wonder_jest.test("index should be intersected shader's length + 1", (function () {
                                                              var match = _prepare(state[0]);
                                                              var match$1 = ShaderTool$Wonderjs.getShaderData(match[0]);
                                                              var index = match$1[/* index */0];
                                                              return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](index), 1);
                                                            }));
                                              }));
                                        describe("test shaderIndexMap", (function () {
                                                return Wonder_jest.test("get intersect map between current shaderIndexMap and target shaderIndexMap whose value is the one in target shaderIndexMap", (function () {
                                                              var match = _prepare(state[0]);
                                                              var match$1 = ShaderTool$Wonderjs.getShaderData(match[0]);
                                                              var shaderIndexMap = match$1[/* shaderIndexMap */1];
                                                              return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](HashMapSystem$Wonderjs.entries(shaderIndexMap)), /* array */[/* tuple */[
                                                                            "key1",
                                                                            match[2][1][0]
                                                                          ]]);
                                                            }));
                                              }));
                                        return /* () */0;
                                      }));
                                describe("test restore program data", (function () {
                                        describe("test programMap", (function () {
                                                return Wonder_jest.test("get intersect map between current programMap and target programMap whose value is the one in current programMap", (function () {
                                                              var match = _prepare(state[0]);
                                                              var match$1 = ProgramTool$Wonderjs.getProgramData(match[0]);
                                                              var programMap = match$1[/* programMap */0];
                                                              return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                                              SparseMapSystem$Wonderjs.length(programMap),
                                                                              SparseMapSystem$WonderCommonlib.unsafeGet(match[2][1][0], programMap)
                                                                            ]), /* tuple */[
                                                                          1,
                                                                          match[1][2][0]
                                                                        ]);
                                                            }));
                                              }));
                                        return /* () */0;
                                      }));
                                describe("test restore glsl location data", (function () {
                                        describe("test attributeLocationMap, uniformLocationMap", (function () {
                                                return Wonder_jest.test("get intersect map between current map and target map whose value is the one in current map", (function () {
                                                              var match = _prepare(state[0]);
                                                              var match$1 = GLSLLocationTool$Wonderjs.getGLSLLocationData(match[0]);
                                                              var attributeLocationMap = match$1[/* attributeLocationMap */0];
                                                              return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                                              SparseMapSystem$Wonderjs.length(attributeLocationMap),
                                                                              SparseMapSystem$WonderCommonlib.unsafeGet(match[2][1][0], attributeLocationMap)
                                                                            ]), /* tuple */[
                                                                          1,
                                                                          match[1][3][0]
                                                                        ]);
                                                            }));
                                              }));
                                        return /* () */0;
                                      }));
                                describe("test restore glsl sender data", (function () {
                                        describe("test shaderUniformSendNoCacheableDataMap", (function () {
                                                return Wonder_jest.test("get intersect map between current shaderUniformSendNoCacheableDataMap and target shaderUniformSendNoCacheableDataMap whose value is the one in current shaderUniformSendNoCacheableDataMap", (function () {
                                                              var match = _prepare(state[0]);
                                                              var match$1 = GLSLSenderTool$Wonderjs.getGLSLSenderData(match[0]);
                                                              var shaderUniformSendNoCacheableDataMap = match$1[/* shaderUniformSendNoCacheableDataMap */5];
                                                              return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                                              SparseMapSystem$Wonderjs.length(shaderUniformSendNoCacheableDataMap),
                                                                              SparseMapSystem$WonderCommonlib.unsafeGet(match[2][1][0], shaderUniformSendNoCacheableDataMap)
                                                                            ]), /* tuple */[
                                                                          1,
                                                                          match[1][4][0]
                                                                        ]);
                                                            }));
                                              }));
                                        return /* () */0;
                                      }));
                                return /* () */0;
                              }));
                        return /* () */0;
                      }));
                return /* () */0;
              }));
        return /* () */0;
      }));

export {
  
}
/*  Not a pure module */
