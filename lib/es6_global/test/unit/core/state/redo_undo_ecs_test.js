// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Curry                           from "../../../../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Sinon                           from "../../../../../../node_modules/wonder-bs-sinon/lib/es6_global/src/sinon.js";
import * as Sinon$1                         from "sinon";
import * as Wonder_jest                     from "../../../../../../node_modules/wonder-bs-jest/lib/es6_global/src/wonder_jest.js";
import * as Js_primitive                    from "../../../../../../node_modules/bs-platform/lib/es6/js_primitive.js";
import * as GlTool$Wonderjs                 from "../../tool/gl/GlTool.js";
import * as Geometry$Wonderjs               from "../../../../src/ecs/component/api/geometry/Geometry.js";
import * as Material$Wonderjs               from "../../../../src/ecs/component/api/material/Material.js";
import * as TestTool$Wonderjs               from "../../tool/TestTool.js";
import * as JudgeTool$Wonderjs              from "../../tool/JudgeTool.js";
import * as StateTool$Wonderjs              from "../../tool/core/StateTool.js";
import * as Transform$Wonderjs              from "../../../../src/ecs/component/api/transform/Transform.js";
import * as FakeGlTool$Wonderjs             from "../../tool/gl/FakeGlTool.js";
import * as GameObject$Wonderjs             from "../../../../src/ecs/admin/api/GameObject.js";
import * as GeometryTool$Wonderjs           from "../../tool/component/geometry/GeometryTool.js";
import * as MaterialTool$Wonderjs           from "../../tool/component/material/MaterialTool.js";
import * as MeshRenderer$Wonderjs           from "../../../../src/ecs/component/api/meshRenderer/MeshRenderer.js";
import * as TransformTool$Wonderjs          from "../../tool/component/transform/TransformTool.js";
import * as GameObjectTool$Wonderjs         from "../../tool/core/GameObjectTool.js";
import * as BoxGeometryTool$Wonderjs        from "../../tool/component/geometry/BoxGeometryTool.js";
import * as MeshRendererTool$Wonderjs       from "../../tool/component/meshRenderer/MeshRendererTool.js";
import * as BasicMaterialTool$Wonderjs      from "../../tool/component/material/BasicMaterialTool.js";
import * as PerspectiveCamera$Wonderjs      from "../../../../src/ecs/component/api/cameraController/PerspectiveCamera.js";
import * as TypeArrayPoolTool$Wonderjs      from "../../tool/structure/TypeArrayPoolTool.js";
import * as ObjectInstanceTool$Wonderjs     from "../../tool/component/instance/ObjectInstanceTool.js";
import * as SourceInstanceTool$Wonderjs     from "../../tool/component/instance/SourceInstanceTool.js";
import * as CameraControllerTool$Wonderjs   from "../../tool/component/cameraController/CameraControllerTool.js";
import * as SparseMapSystem$WonderCommonlib from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapSystem.js";

describe("test redo,undo component data", (function () {
        var sandbox = Sinon.getSandboxDefaultVal(/* () */0);
        var state = [StateTool$Wonderjs.createState(/* None */0, /* () */0)];
        var _prepareMeshRendererData = function (state) {
          var match = MeshRendererTool$Wonderjs.createGameObject(state[0]);
          var match$1 = MeshRendererTool$Wonderjs.createGameObject(match[0]);
          var match$2 = MeshRendererTool$Wonderjs.createGameObject(match$1[0]);
          var meshRenderer3 = match$2[2];
          var gameObject3 = match$2[1];
          var state$1 = GameObject$Wonderjs.disposeGameObjectMeshRendererComponent(gameObject3, meshRenderer3, match$2[0]);
          return /* tuple */[
                  state$1,
                  match[1],
                  match$1[1],
                  gameObject3,
                  match[2],
                  match$1[2],
                  meshRenderer3
                ];
        };
        var _prepareTransformData = function (state) {
          var match = GameObjectTool$Wonderjs.createGameObject(state[0]);
          var transform1 = match[2];
          var match$1 = GameObjectTool$Wonderjs.createGameObject(match[0]);
          var transform2 = match$1[2];
          var match$2 = GameObjectTool$Wonderjs.createGameObject(match$1[0]);
          var transform3 = match$2[2];
          var gameObject3 = match$2[1];
          var state$1 = Transform$Wonderjs.setTransformParent(transform1, transform2, match$2[0]);
          var state$2 = Transform$Wonderjs.setTransformLocalPosition(transform1, /* tuple */[
                1,
                2,
                3
              ], state$1);
          var state$3 = Transform$Wonderjs.setTransformLocalPosition(transform2, /* tuple */[
                2,
                4,
                10
              ], state$2);
          var state$4 = Transform$Wonderjs.setTransformLocalPosition(transform3, /* tuple */[
                -1,
                4,
                5
              ], state$3);
          var state$5 = GameObject$Wonderjs.disposeGameObjectTransformComponent(gameObject3, transform3, state$4);
          return /* tuple */[
                  state$5,
                  match[1],
                  match$1[1],
                  gameObject3,
                  transform1,
                  transform2,
                  transform3
                ];
        };
        var _prepareCameraControllerData = function (state) {
          var match = CameraControllerTool$Wonderjs.createCameraGameObject(state[0]);
          var cameraController1 = match[3];
          var match$1 = CameraControllerTool$Wonderjs.createCameraGameObject(match[0]);
          var cameraController2 = match$1[3];
          var match$2 = CameraControllerTool$Wonderjs.createCameraGameObject(match$1[0]);
          var cameraController3 = match$2[3];
          var gameObject3 = match$2[1];
          var state$1 = PerspectiveCamera$Wonderjs.setPerspectiveCameraNear(cameraController2, 0.2, match$2[0]);
          var state$2 = PerspectiveCamera$Wonderjs.setPerspectiveCameraFar(cameraController2, 100, state$1);
          var state$3 = PerspectiveCamera$Wonderjs.setPerspectiveCameraFar(cameraController3, 100, state$2);
          var state$4 = PerspectiveCamera$Wonderjs.setPerspectiveCameraAspect(cameraController1, 1, state$3);
          var state$5 = PerspectiveCamera$Wonderjs.setPerspectiveCameraAspect(cameraController2, 2, state$4);
          var state$6 = PerspectiveCamera$Wonderjs.setPerspectiveCameraFovy(cameraController2, 60, state$5);
          var state$7 = CameraControllerTool$Wonderjs.update(state$6);
          var state$8 = GameObject$Wonderjs.disposeGameObjectCameraControllerComponent(gameObject3, cameraController3, state$7);
          return /* tuple */[
                  state$8,
                  match[1],
                  match$1[1],
                  gameObject3,
                  cameraController1,
                  cameraController2,
                  cameraController3
                ];
        };
        var _prepareGeometryData = function (state) {
          var match = BoxGeometryTool$Wonderjs.createGameObject(state[0]);
          var match$1 = BoxGeometryTool$Wonderjs.createGameObject(match[0]);
          var geometry2 = match$1[2];
          var match$2 = BoxGeometryTool$Wonderjs.createGameObject(match$1[0]);
          var state$1 = GeometryTool$Wonderjs.initGeometrys(match$2[0]);
          var state$2 = Geometry$Wonderjs.setGeometryVertices(geometry2, new Float32Array(/* float array */[
                    3,
                    5,
                    5
                  ]), state$1);
          var state$3 = Geometry$Wonderjs.setGeometryIndices(geometry2, new Uint16Array(/* int array */[
                    1,
                    2,
                    4
                  ]), state$2);
          return /* tuple */[
                  state$3,
                  match[1],
                  match$1[1],
                  match$2[1],
                  match[2],
                  geometry2,
                  match$2[2]
                ];
        };
        var _prepareMaterialData = function (state) {
          var match = BasicMaterialTool$Wonderjs.createGameObject(state[0]);
          var match$1 = BasicMaterialTool$Wonderjs.createGameObject(match[0]);
          var material2 = match$1[2];
          var match$2 = BasicMaterialTool$Wonderjs.createGameObject(match$1[0]);
          var state$1 = MaterialTool$Wonderjs.prepareForInit(match$2[0]);
          var state$2 = FakeGlTool$Wonderjs.setFakeGl(FakeGlTool$Wonderjs.buildFakeGl(sandbox, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* () */0), state$1);
          var state$3 = BasicMaterialTool$Wonderjs.initMaterials(GlTool$Wonderjs.getGl(state$2), state$2);
          var state$4 = Material$Wonderjs.setMaterialColor(material2, /* float array */[
                1,
                0.1,
                0.2
              ], state$3);
          return /* tuple */[
                  state$4,
                  match[1],
                  match$1[1],
                  match$2[1],
                  match[2],
                  material2,
                  match$2[2]
                ];
        };
        beforeEach((function () {
                sandbox[0] = Sinon$1.sandbox.create();
                state[0] = TestTool$Wonderjs.init(sandbox, /* None */0, /* None */0, /* () */0);
                return /* () */0;
              }));
        afterEach((function () {
                return Curry._1(Sinon.restoreSandbox, sandbox[0]);
              }));
        describe("deepCopyStateForRestore", (function () {
                describe("deep copy meshRenderer data", (function () {
                        Wonder_jest.test("copied data should equal to source data", (function () {
                                var match = _prepareMeshRendererData(state);
                                var gameObject2 = match[2];
                                var gameObject1 = match[1];
                                var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(match[0]);
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](MeshRendererTool$Wonderjs.getMeshRendererData(copiedState)), /* record */[
                                            /* index */3,
                                            /* renderGameObjectArray : int array */[
                                              gameObject1,
                                              gameObject2
                                            ],
                                            /* gameObjectMap : int array */[
                                              gameObject1,
                                              gameObject2,
                                              undefined
                                            ],
                                            /* disposedIndexArray : int array */[match[6]]
                                          ]);
                              }));
                        return Wonder_jest.test("change copied state shouldn't affect source state", (function () {
                                      var match = _prepareMeshRendererData(state);
                                      var gameObject2 = match[2];
                                      var gameObject1 = match[1];
                                      var state$1 = match[0];
                                      var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$1);
                                      var data = MeshRendererTool$Wonderjs.getMeshRendererData(copiedState);
                                      data[/* index */0] = 0;
                                      Js_primitive.undefined_to_opt(data[/* renderGameObjectArray */1].pop());
                                      SparseMapSystem$WonderCommonlib.deleteVal(match[5], data[/* gameObjectMap */2]);
                                      Js_primitive.undefined_to_opt(data[/* disposedIndexArray */3].pop());
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](MeshRendererTool$Wonderjs.getMeshRendererData(state$1)), /* record */[
                                                  /* index */3,
                                                  /* renderGameObjectArray : int array */[
                                                    gameObject1,
                                                    gameObject2
                                                  ],
                                                  /* gameObjectMap : int array */[
                                                    gameObject1,
                                                    gameObject2,
                                                    undefined
                                                  ],
                                                  /* disposedIndexArray : int array */[match[6]]
                                                ]);
                                    }));
                      }));
                describe("deep copy transform data", (function () {
                        return Wonder_jest.test("change copied state shouldn't affect source state", (function () {
                                      var match = _prepareTransformData(state);
                                      var transform2 = match[5];
                                      var state$1 = match[0];
                                      Transform$Wonderjs.getTransformPosition(transform2, state$1);
                                      var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$1);
                                      var data = TransformTool$Wonderjs.getTransformData(copiedState);
                                      SparseMapSystem$WonderCommonlib.deleteVal(transform2, data[/* localPositionMap */5]);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* not_ */22](Wonder_jest.Expect[/* expect */0](SparseMapSystem$WonderCommonlib.unsafeGet(transform2, TransformTool$Wonderjs.getTransformData(state$1)[/* localPositionMap */5]))), undefined);
                                    }));
                      }));
                describe("deep copy geometry data", (function () {
                        return Wonder_jest.test("change copied state shouldn't affect source state", (function () {
                                      var match = _prepareGeometryData(state);
                                      var geometry2 = match[5];
                                      var state$1 = match[0];
                                      var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$1);
                                      var data = GeometryTool$Wonderjs.getGeometryData(copiedState);
                                      SparseMapSystem$WonderCommonlib.deleteVal(geometry2, data[/* verticesMap */1]);
                                      SparseMapSystem$WonderCommonlib.deleteVal(geometry2, data[/* indicesMap */2]);
                                      var match$1 = GeometryTool$Wonderjs.getGeometryData(state$1);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* not_ */22](Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                          SparseMapSystem$WonderCommonlib.unsafeGet(geometry2, match$1[/* verticesMap */1]),
                                                          SparseMapSystem$WonderCommonlib.unsafeGet(geometry2, match$1[/* indicesMap */2])
                                                        ])), undefined);
                                    }));
                      }));
                describe("deep copy material data", (function () {
                        return Wonder_jest.test("change copied state shouldn't affect source state", (function () {
                                      var match = _prepareMaterialData(state);
                                      var material2 = match[5];
                                      var state$1 = match[0];
                                      var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$1);
                                      var data = MaterialTool$Wonderjs.getMaterialData(copiedState);
                                      SparseMapSystem$WonderCommonlib.deleteVal(material2, data[/* colorMap */2]);
                                      var match$1 = MaterialTool$Wonderjs.getMaterialData(state$1);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* not_ */22](Wonder_jest.Expect[/* expect */0](SparseMapSystem$WonderCommonlib.unsafeGet(material2, match$1[/* colorMap */2]))), undefined);
                                    }));
                      }));
                describe("deep copy sourceInstance data", (function () {
                        Wonder_jest.test("deep copy objectInstanceArrayMap, modelMatrixFloat32ArrayMap", (function () {
                                var match = SourceInstanceTool$Wonderjs.createSourceInstanceGameObject(state[0]);
                                var sourceInstance1 = match[2];
                                var state$1 = match[0];
                                var match$1 = SourceInstanceTool$Wonderjs.getSourceInstanceData(state$1);
                                var objectInstanceArrayMap = match$1[/* objectInstanceArrayMap */1];
                                var originModelMatrixFloat32Array = new Float32Array(/* float array */[1]);
                                SparseMapSystem$WonderCommonlib.set(sourceInstance1, originModelMatrixFloat32Array, match$1[/* modelMatrixFloat32ArrayMap */3]);
                                var originObjectInstanceArray = /* int array */[20];
                                SparseMapSystem$WonderCommonlib.set(sourceInstance1, originObjectInstanceArray, objectInstanceArrayMap);
                                var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$1);
                                var match$2 = SourceInstanceTool$Wonderjs.getSourceInstanceData(copiedState);
                                var objectInstanceArrayMap$1 = match$2[/* objectInstanceArrayMap */1];
                                var objectInstanceArray = SparseMapSystem$WonderCommonlib.unsafeGet(sourceInstance1, objectInstanceArrayMap$1);
                                objectInstanceArray.push(100);
                                var modelMatrixFloat32Array = SparseMapSystem$WonderCommonlib.unsafeGet(sourceInstance1, match$2[/* modelMatrixFloat32ArrayMap */3]);
                                modelMatrixFloat32Array[0] = 1000;
                                var match$3 = SourceInstanceTool$Wonderjs.getSourceInstanceData(state$1);
                                var objectInstanceArrayMap$2 = match$3[/* objectInstanceArrayMap */1];
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                SparseMapSystem$WonderCommonlib.unsafeGet(sourceInstance1, objectInstanceArrayMap$2),
                                                SparseMapSystem$WonderCommonlib.unsafeGet(sourceInstance1, match$3[/* modelMatrixFloat32ArrayMap */3])
                                              ]), /* tuple */[
                                            originObjectInstanceArray,
                                            originModelMatrixFloat32Array
                                          ]);
                              }));
                        return Wonder_jest.test("shadow copy modelMatrixInstanceBufferCapacityMap, isModelMatrixStaticMap, gameObjectMap, disposedIndexArray", (function () {
                                      return StateTool$Wonderjs.testShadowCopyArrayLikeMapData((function (state) {
                                                    var match = SourceInstanceTool$Wonderjs.getSourceInstanceData(state);
                                                    var disposedIndexArray = match[/* disposedIndexArray */6];
                                                    return /* array */[
                                                            match[/* modelMatrixInstanceBufferCapacityMap */2],
                                                            match[/* isModelMatrixStaticMap */4],
                                                            match[/* gameObjectMap */7],
                                                            disposedIndexArray
                                                          ];
                                                  }), state[0]);
                                    }));
                      }));
                describe("deep copy gameObject data", (function () {
                        return Wonder_jest.test("shadow copy disposedUidMap, aliveUidArray, transformMap, cameraControllerMap, geometryMap, meshRendererMap, materialMap, sourceInstanceMap, objectInstanceMap", (function () {
                                      return StateTool$Wonderjs.testShadowCopyArrayLikeMapData((function (state) {
                                                    var match = GameObjectTool$Wonderjs.getGameObjectData(state);
                                                    var disposedUidMap = match[/* disposedUidMap */2];
                                                    var aliveUidArray = match[/* aliveUidArray */3];
                                                    var transformMap = match[/* transformMap */4];
                                                    var cameraControllerMap = match[/* cameraControllerMap */5];
                                                    var geometryMap = match[/* geometryMap */6];
                                                    var meshRendererMap = match[/* meshRendererMap */7];
                                                    var materialMap = match[/* materialMap */8];
                                                    var sourceInstanceMap = match[/* sourceInstanceMap */9];
                                                    var objectInstanceMap = match[/* objectInstanceMap */10];
                                                    return /* array */[
                                                            disposedUidMap,
                                                            aliveUidArray,
                                                            transformMap,
                                                            cameraControllerMap,
                                                            geometryMap,
                                                            meshRendererMap,
                                                            materialMap,
                                                            sourceInstanceMap,
                                                            objectInstanceMap
                                                          ];
                                                  }), state[0]);
                                    }));
                      }));
                describe("deep copy objectInstance data", (function () {
                        return Wonder_jest.test("shadow copy sourceInstanceMap, gameObjectMap, disposedIndexArray", (function () {
                                      return StateTool$Wonderjs.testShadowCopyArrayLikeMapData((function (state) {
                                                    var match = ObjectInstanceTool$Wonderjs.getObjectInstanceData(state);
                                                    var disposedIndexArray = match[/* disposedIndexArray */2];
                                                    return /* array */[
                                                            match[/* sourceInstanceMap */1],
                                                            match[/* gameObjectMap */3],
                                                            disposedIndexArray
                                                          ];
                                                  }), state[0]);
                                    }));
                      }));
                describe("deep copy cameraController data", (function () {
                        return Wonder_jest.test("change copied state shouldn't affect source state", (function () {
                                      var match = _prepareCameraControllerData(state);
                                      var cameraController2 = match[5];
                                      var cameraController1 = match[4];
                                      var state$1 = match[0];
                                      var copiedState = StateTool$Wonderjs.deepCopyStateForRestore(state$1);
                                      var data = CameraControllerTool$Wonderjs.getCameraControllerData(copiedState);
                                      var perspectiveCameraData = data[/* perspectiveCameraData */6];
                                      SparseMapSystem$WonderCommonlib.deleteVal(cameraController2, data[/* cameraArray */1]);
                                      SparseMapSystem$WonderCommonlib.deleteVal(cameraController2, data[/* updateCameraFuncMap */5]);
                                      SparseMapSystem$WonderCommonlib.deleteVal(cameraController1, perspectiveCameraData[/* nearMap */0]);
                                      var match$1 = CameraControllerTool$Wonderjs.getCameraControllerData(state$1);
                                      var cameraArray = match$1[/* cameraArray */1];
                                      var updateCameraFuncMap = match$1[/* updateCameraFuncMap */5];
                                      var perspectiveCameraData$1 = match$1[/* perspectiveCameraData */6];
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                      cameraArray,
                                                      JudgeTool$Wonderjs.isUndefined(SparseMapSystem$WonderCommonlib.unsafeGet(cameraController2, updateCameraFuncMap)),
                                                      perspectiveCameraData$1[/* nearMap */0]
                                                    ]), /* tuple */[
                                                  /* int array */[
                                                    cameraController1,
                                                    cameraController2,
                                                    undefined
                                                  ],
                                                  /* false */0,
                                                  /* float array */[
                                                    0.1,
                                                    0.2,
                                                    undefined
                                                  ]
                                                ]);
                                    }));
                      }));
                return /* () */0;
              }));
        describe("restore", (function () {
                var _testRestoreStateEqualTargetState = function (state, prepareDataFunc, getDataFunc) {
                  var match = Curry._1(prepareDataFunc, state);
                  var state$1 = match[0];
                  var currentState = StateTool$Wonderjs.createNewCompleteState(/* () */0);
                  var match$1 = Curry._1(prepareDataFunc, [currentState]);
                  StateTool$Wonderjs.restore(match$1[0], state$1);
                  return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](Curry._1(getDataFunc, StateTool$Wonderjs.getState(/* () */0))), Curry._1(getDataFunc, state$1));
                };
                describe("restore meshRenderer data to target state", (function () {
                        var _prepare = function (state) {
                          var match = _prepareMeshRendererData(state);
                          var match$1 = MeshRendererTool$Wonderjs.createGameObject(StateTool$Wonderjs.createNewCompleteState(/* () */0));
                          return /* tuple */[
                                  /* tuple */[
                                    match[0],
                                    match[1],
                                    match[2],
                                    match[3],
                                    match[4],
                                    match[5],
                                    match[6]
                                  ],
                                  /* tuple */[
                                    match$1[0],
                                    match$1[1],
                                    match$1[2]
                                  ]
                                ];
                        };
                        Wonder_jest.test("set restored state to stateData", (function () {
                                var match = _prepare(state);
                                var currentState = StateTool$Wonderjs.restore(match[1][0], match[0][0]);
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](StateTool$Wonderjs.getState(/* () */0)), currentState);
                              }));
                        Wonder_jest.test("change restored state should affect source state", (function () {
                                var match = _prepare(state);
                                var state$1 = match[0][0];
                                StateTool$Wonderjs.restore(match[1][0], state$1);
                                var match$1 = MeshRendererTool$Wonderjs.createGameObject(StateTool$Wonderjs.createNewCompleteState(/* () */0));
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](MeshRenderer$Wonderjs.getMeshRendererGameObject(match$1[2], state$1)), match$1[1]);
                              }));
                        return Wonder_jest.test("change restored state which is restore from deep copied state shouldn't affect source state", (function () {
                                      var match = _prepare(state);
                                      var match$1 = match[0];
                                      var state$1 = match$1[0];
                                      var currentState = StateTool$Wonderjs.restore(match[1][0], StateTool$Wonderjs.deepCopyStateForRestore(state$1));
                                      MeshRendererTool$Wonderjs.createGameObject(currentState);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](MeshRendererTool$Wonderjs.getMeshRendererData(state$1)[/* renderGameObjectArray */1]), /* int array */[
                                                  match$1[1],
                                                  match$1[2]
                                                ]);
                                    }));
                      }));
                describe("restore transform data to target state", (function () {
                        return Wonder_jest.test("add current state->transformData->localToWorldMatrixMap, localPositionMap typeArr to pool", (function () {
                                      var match = _prepareTransformData(state);
                                      var match$1 = GameObjectTool$Wonderjs.createGameObject(StateTool$Wonderjs.createNewCompleteState(/* () */0));
                                      var pos4 = /* tuple */[
                                        -1,
                                        4,
                                        5
                                      ];
                                      var currentState = Transform$Wonderjs.setTransformLocalPosition(match$1[2], pos4, match$1[0]);
                                      StateTool$Wonderjs.restore(currentState, match[0]);
                                      var match$2 = TypeArrayPoolTool$Wonderjs.getTypeArrayPoolData(StateTool$Wonderjs.getState(/* () */0));
                                      var float32ArrayPoolMap = match$2[/* float32ArrayPoolMap */0];
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                      SparseMapSystem$WonderCommonlib.unsafeGet(16, float32ArrayPoolMap),
                                                      SparseMapSystem$WonderCommonlib.unsafeGet(3, float32ArrayPoolMap)
                                                    ]), /* tuple */[
                                                  /* array */[TransformTool$Wonderjs.getDefaultLocalToWorldMatrix(/* () */0)],
                                                  /* array */[TransformTool$Wonderjs.changeTupleToTypeArray(pos4)]
                                                ]);
                                    }));
                      }));
                describe("restore geometry data to target state", (function () {
                        return Wonder_jest.test("add current state->geometryData->verticesMap, indicesMap typeArr to pool", (function () {
                                      var match = _prepareGeometryData(state);
                                      var match$1 = BoxGeometryTool$Wonderjs.createGameObject(StateTool$Wonderjs.createNewCompleteState(/* () */0));
                                      var currentState = GeometryTool$Wonderjs.initGeometry(match$1[2], match$1[0]);
                                      StateTool$Wonderjs.restore(currentState, match[0]);
                                      var match$2 = TypeArrayPoolTool$Wonderjs.getTypeArrayPoolData(StateTool$Wonderjs.getState(/* () */0));
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                      SparseMapSystem$WonderCommonlib.unsafeGet(BoxGeometryTool$Wonderjs.getDefaultVertices(/* () */0).length, match$2[/* float32ArrayPoolMap */0]),
                                                      SparseMapSystem$WonderCommonlib.unsafeGet(BoxGeometryTool$Wonderjs.getDefaultIndices(/* () */0).length, match$2[/* uint16ArrayPoolMap */1])
                                                    ]), /* tuple */[
                                                  /* array */[BoxGeometryTool$Wonderjs.getDefaultVertices(/* () */0)],
                                                  /* array */[BoxGeometryTool$Wonderjs.getDefaultIndices(/* () */0)]
                                                ]);
                                    }));
                      }));
                Wonder_jest.test("restore material data to target state", (function () {
                        return _testRestoreStateEqualTargetState(state, _prepareMaterialData, MaterialTool$Wonderjs.getMaterialData);
                      }));
                describe("restore sourceInstance data to target state", (function () {
                        Wonder_jest.test("add current state->sourceInstanceData->modelMatrixFloat32ArrayMap typeArr to pool", (function () {
                                var state$1 = state[0];
                                var currentState = StateTool$Wonderjs.createNewCompleteState(/* () */0);
                                var match = SourceInstanceTool$Wonderjs.getSourceInstanceData(currentState);
                                var typeArr = new Float32Array(/* float array */[1]);
                                SparseMapSystem$WonderCommonlib.set(0, typeArr, match[/* modelMatrixFloat32ArrayMap */3]);
                                StateTool$Wonderjs.restore(currentState, state$1);
                                var match$1 = TypeArrayPoolTool$Wonderjs.getTypeArrayPoolData(StateTool$Wonderjs.getState(/* () */0));
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](SparseMapSystem$WonderCommonlib.unsafeGet(typeArr.length, match$1[/* float32ArrayPoolMap */0])), /* array */[typeArr]);
                              }));
                        return Wonder_jest.test("mark is-not-send-modelMatrixData", (function () {
                                      var state$1 = state[0];
                                      var match = SourceInstanceTool$Wonderjs.getSourceInstanceData(state$1);
                                      SparseMapSystem$WonderCommonlib.set(1, /* false */0, SparseMapSystem$WonderCommonlib.set(0, /* true */1, match[/* isSendModelMatrixDataMap */5]));
                                      StateTool$Wonderjs.restore(StateTool$Wonderjs.createNewCompleteState(/* () */0), state$1);
                                      var match$1 = SourceInstanceTool$Wonderjs.getSourceInstanceData(StateTool$Wonderjs.getState(/* () */0));
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](match$1[/* isSendModelMatrixDataMap */5]), /* int array */[
                                                  /* false */0,
                                                  /* false */0
                                                ]);
                                    }));
                      }));
                return Wonder_jest.test("restore cameraController data to target state", (function () {
                              return _testRestoreStateEqualTargetState(state, _prepareCameraControllerData, CameraControllerTool$Wonderjs.getCameraControllerData);
                            }));
              }));
        return /* () */0;
      }));

export {
  
}
/*  Not a pure module */
