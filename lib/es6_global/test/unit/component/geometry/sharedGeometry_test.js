// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Curry                      from "../../../../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Sinon                      from "../../../../../../node_modules/wonder-bs-sinon/lib/es6_global/src/sinon.js";
import * as Sinon$1                    from "sinon";
import * as Caml_array                 from "../../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Wonder_jest                from "../../../../../../node_modules/wonder-bs-jest/lib/es6_global/src/wonder_jest.js";
import * as Geometry$Wonderjs          from "../../../../src/ecs/component/api/geometry/Geometry.js";
import * as TestTool$Wonderjs          from "../../tool/TestTool.js";
import * as CloneTool$Wonderjs         from "../../tool/core/CloneTool.js";
import * as StateTool$Wonderjs         from "../../tool/core/StateTool.js";
import * as FakeGlTool$Wonderjs        from "../../tool/gl/FakeGlTool.js";
import * as GameObject$Wonderjs        from "../../../../src/ecs/admin/api/GameObject.js";
import * as ArraySystem$Wonderjs       from "../../../../src/structure/ArraySystem.js";
import * as GeometryTool$Wonderjs      from "../../tool/component/geometry/GeometryTool.js";
import * as VboBufferTool$Wonderjs     from "../../tool/render/buffer/VboBufferTool.js";
import * as BoxGeometryTool$Wonderjs   from "../../tool/component/geometry/BoxGeometryTool.js";
import * as MemoryConfigTool$Wonderjs  from "../../tool/config/MemoryConfigTool.js";
import * as GeometryGroupTool$Wonderjs from "../../tool/component/geometry/GeometryGroupTool.js";

describe("test shared geometry", (function () {
        var sandbox = Sinon.getSandboxDefaultVal(/* () */0);
        var state = [StateTool$Wonderjs.createState(/* None */0, /* () */0)];
        var _createAndInit = function (state) {
          var match = BoxGeometryTool$Wonderjs.createGameObject(state);
          var geometry1 = match[2];
          var match$1 = GeometryGroupTool$Wonderjs.createGameObjectWithSharedGeometry(geometry1, match[0]);
          return /* tuple */[
                  GeometryTool$Wonderjs.initGeometrys(match$1[0]),
                  match[1],
                  geometry1,
                  match$1[1],
                  match$1[2]
                ];
        };
        beforeEach((function () {
                sandbox[0] = Sinon$1.sandbox.create();
                state[0] = TestTool$Wonderjs.init(sandbox, /* None */0, /* None */0, /* () */0);
                return /* () */0;
              }));
        afterEach((function () {
                return Curry._1(Sinon.restoreSandbox, sandbox[0]);
              }));
        Wonder_jest.test("shared geometry can be added to gameObject", (function () {
                var match = _createAndInit(state[0]);
                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](GameObject$Wonderjs.getGameObjectGeometryComponent(match[3], match[0])), match[2]);
              }));
        Wonder_jest.test("shared geometry can get the same gameObject(first gameObject)", (function () {
                var match = _createAndInit(state[0]);
                var gameObject1 = match[1];
                var state$1 = match[0];
                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                Geometry$Wonderjs.getGeometryGameObject(match[2], state$1),
                                Geometry$Wonderjs.getGeometryGameObject(match[4], state$1)
                              ]), /* tuple */[
                            gameObject1,
                            gameObject1
                          ]);
              }));
        describe("test clone geometry component", (function () {
                var _createAndInitGameObject = function (state) {
                  var match = BoxGeometryTool$Wonderjs.createGameObject(state);
                  var gameObject1 = match[1];
                  var state$1 = GameObject$Wonderjs.initGameObject(gameObject1, match[0]);
                  return /* tuple */[
                          state$1,
                          gameObject1,
                          match[2]
                        ];
                };
                var _prepare = function (state) {
                  var match = _createAndInitGameObject(state);
                  return CloneTool$Wonderjs.cloneWithGeometry(match[0], match[1], match[2], 2);
                };
                var _initClonedGeometrys = function (clonedGeometryArr, state) {
                  return ArraySystem$Wonderjs.reduceState((function (state, clonedGeometry) {
                                return GeometryTool$Wonderjs.initGeometry(clonedGeometry, state);
                              }), state, clonedGeometryArr);
                };
                Wonder_jest.test("cloned geometrys share geometry with source geometry", (function () {
                        var match = _prepare(state[0]);
                        var geometry = match[2];
                        return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](match[4]), /* int array */[
                                    geometry,
                                    geometry
                                  ]);
                      }));
                describe("test init cloned geometry", (function () {
                        return Wonder_jest.test("not init cloned geometry", (function () {
                                      var match = _prepare(state[0]);
                                      var clonedGeometryArr = match[4];
                                      var match$1 = GeometryTool$Wonderjs.createStubComputeFuncData(sandbox, Caml_array.caml_array_get(clonedGeometryArr, 0), match[0]);
                                      var match$2 = GeometryTool$Wonderjs.createStubComputeFuncData(sandbox, Caml_array.caml_array_get(clonedGeometryArr, 1), match$1[0]);
                                      _initClonedGeometrys(clonedGeometryArr, match$2[0]);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                      Sinon.getCallCount(match$1[1]),
                                                      Sinon.getCallCount(match$2[1])
                                                    ]), /* tuple */[
                                                  0,
                                                  0
                                                ]);
                                    }));
                      }));
                describe("test dispose cloned geometry", (function () {
                        var _prepare = function (state) {
                          var match = _createAndInitGameObject(state);
                          return CloneTool$Wonderjs.cloneWithGeometry(match[0], match[1], match[2], 1);
                        };
                        Wonder_jest.test("not collect dispose index", (function () {
                                var match = _prepare(state[0]);
                                var state$1 = GeometryTool$Wonderjs.disposeGeometryByCloseContractCheck(Caml_array.caml_array_get(match[3], 0), Caml_array.caml_array_get(match[4], 0), match[0]);
                                var match$1 = GeometryTool$Wonderjs.getGeometryData(state$1);
                                var disposedIndexArray = match$1[/* disposedIndexArray */6];
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](disposedIndexArray), /* int array */[]);
                              }));
                        Wonder_jest.test("dispose all cloned geometry shouldn't cause really dispose", (function () {
                                var match = _prepare(state[0]);
                                var state$1 = GeometryTool$Wonderjs.disposeGeometryByCloseContractCheck(Caml_array.caml_array_get(match[3], 0), Caml_array.caml_array_get(match[4], 0), match[0]);
                                var match$1 = GeometryTool$Wonderjs.getGeometryData(state$1);
                                var gameObjectMap = match$1[/* gameObjectMap */5];
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](gameObjectMap), /* int array */[0]);
                              }));
                        return Wonder_jest.test("dispose all cloned geometry and source geometry should cause really dispose", (function () {
                                      var match = _prepare(state[0]);
                                      var geometry1 = match[2];
                                      var state$1 = GeometryTool$Wonderjs.disposeGeometryByCloseContractCheck(Caml_array.caml_array_get(match[3], 0), Caml_array.caml_array_get(match[4], 0), match[0]);
                                      var state$2 = GeometryTool$Wonderjs.disposeGeometryByCloseContractCheck(match[1], geometry1, state$1);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](GeometryTool$Wonderjs.isGeometryDisposed(geometry1, state$2)), /* true */1);
                                    }));
                      }));
                describe("test batch dispose cloned geometry", (function () {
                        var _prepare = function (state) {
                          var state$1 = MemoryConfigTool$Wonderjs.setConfig(state, /* Some */[1], /* () */0);
                          var match = _createAndInitGameObject(state$1);
                          return CloneTool$Wonderjs.cloneWithGeometry(match[0], match[1], match[2], 1);
                        };
                        Wonder_jest.test("not collect dispose index", (function () {
                                var match = _prepare(state[0]);
                                var state$1 = GeometryTool$Wonderjs.batchDisposeGeometryByCloseContractCheck(/* int array */[Caml_array.caml_array_get(match[3], 0)], match[0]);
                                var match$1 = GeometryTool$Wonderjs.getGeometryData(state$1);
                                var disposedIndexArray = match$1[/* disposedIndexArray */6];
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](disposedIndexArray), /* int array */[]);
                              }));
                        Wonder_jest.test("dispose all cloned geometry shouldn't cause really dispose", (function () {
                                var match = _prepare(state[0]);
                                var state$1 = GeometryTool$Wonderjs.batchDisposeGeometryByCloseContractCheck(/* int array */[Caml_array.caml_array_get(match[3], 0)], match[0]);
                                var match$1 = GeometryTool$Wonderjs.getGeometryData(state$1);
                                var gameObjectMap = match$1[/* gameObjectMap */5];
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](gameObjectMap), /* int array */[0]);
                              }));
                        return Wonder_jest.test("dispose all cloned geometry and source geometry should cause really dispose", (function () {
                                      var match = _prepare(state[0]);
                                      var state$1 = GeometryTool$Wonderjs.batchDisposeGeometryByCloseContractCheck(/* int array */[
                                            match[1],
                                            Caml_array.caml_array_get(match[3], 0)
                                          ], match[0]);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](GeometryTool$Wonderjs.isGeometryDisposed(match[2], state$1)), /* true */1);
                                    }));
                      }));
                return Wonder_jest.test("source geometry's gameObject is cloned geometry's gameObject", (function () {
                              var match = _prepare(state[0]);
                              var clonedGeometryArr = match[4];
                              var gameObject = match[1];
                              var state$1 = match[0];
                              return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                              Geometry$Wonderjs.getGeometryGameObject(Caml_array.caml_array_get(clonedGeometryArr, 0), state$1),
                                              Geometry$Wonderjs.getGeometryGameObject(Caml_array.caml_array_get(clonedGeometryArr, 1), state$1)
                                            ]), /* tuple */[
                                          gameObject,
                                          gameObject
                                        ]);
                            }));
              }));
        describe("test buffer", (function () {
                var _prepare = function (state) {
                  var match = _createAndInit(state);
                  var geometry2 = match[4];
                  var geometry1 = match[2];
                  var createBuffer = Sinon.createEmptyStubWithJsObjSandbox(sandbox);
                  Sinon.returns(10, Sinon.onCall(0, createBuffer));
                  Sinon.returns(12, Sinon.onCall(1, createBuffer));
                  Sinon.returns(11, Sinon.onCall(2, createBuffer));
                  Sinon.returns(13, Sinon.onCall(3, createBuffer));
                  var state$1 = FakeGlTool$Wonderjs.setFakeGl(FakeGlTool$Wonderjs.buildFakeGl(sandbox, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[createBuffer], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* () */0), match[0]);
                  var resultArrayBuffer1 = VboBufferTool$Wonderjs.getOrCreateArrayBuffer(geometry1, state$1);
                  var resultElementArrayBuffer1 = VboBufferTool$Wonderjs.getOrCreateElementArrayBuffer(geometry1, state$1);
                  var resultArrayBuffer2 = VboBufferTool$Wonderjs.getOrCreateArrayBuffer(geometry2, state$1);
                  var resultElementArrayBuffer2 = VboBufferTool$Wonderjs.getOrCreateElementArrayBuffer(geometry2, state$1);
                  return /* tuple */[
                          state$1,
                          /* tuple */[
                            match[1],
                            geometry1,
                            match[3],
                            geometry2
                          ],
                          /* tuple */[
                            createBuffer,
                            10,
                            12,
                            resultArrayBuffer1,
                            resultElementArrayBuffer1,
                            11,
                            13,
                            resultArrayBuffer2,
                            resultElementArrayBuffer2
                          ]
                        ];
                };
                describe("test dispose shared geometry", (function () {
                        beforeEach((function () {
                                state[0] = MemoryConfigTool$Wonderjs.setConfig(state[0], /* Some */[2], /* () */0);
                                return /* () */0;
                              }));
                        Wonder_jest.test("if has other alive shared geometry, not add buffer to pool", (function () {
                                var match = _prepare(state[0]);
                                var match$1 = match[1];
                                var state$1 = GameObject$Wonderjs.disposeGameObjectGeometryComponent(match$1[0], match$1[1], match[0]);
                                var match$2 = VboBufferTool$Wonderjs.getVboBufferData(state$1);
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                match$2[/* vertexArrayBufferPool */3].length,
                                                match$2[/* elementArrayBufferPool */4].length
                                              ]), /* tuple */[
                                            0,
                                            0
                                          ]);
                              }));
                        return Wonder_jest.test("else, add buffer to pool", (function () {
                                      var match = _prepare(state[0]);
                                      var match$1 = match[1];
                                      var state$1 = GameObject$Wonderjs.disposeGameObjectGeometryComponent(match$1[0], match$1[1], match[0]);
                                      var state$2 = GameObject$Wonderjs.disposeGameObjectGeometryComponent(match$1[2], match$1[3], state$1);
                                      var match$2 = VboBufferTool$Wonderjs.getVboBufferData(state$2);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                      match$2[/* vertexArrayBufferPool */3].length,
                                                      match$2[/* elementArrayBufferPool */4].length
                                                    ]), /* tuple */[
                                                  1,
                                                  1
                                                ]);
                                    }));
                      }));
                describe("test batch dispose shared geometry", (function () {
                        beforeEach((function () {
                                state[0] = MemoryConfigTool$Wonderjs.setConfig(state[0], /* Some */[2], /* () */0);
                                return /* () */0;
                              }));
                        Wonder_jest.test("if has other alive shared geometry, not add buffer to pool", (function () {
                                var match = _prepare(state[0]);
                                var state$1 = GameObject$Wonderjs.batchDisposeGameObject(/* int array */[match[1][0]], match[0]);
                                var match$1 = VboBufferTool$Wonderjs.getVboBufferData(state$1);
                                return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                match$1[/* vertexArrayBufferPool */3].length,
                                                match$1[/* elementArrayBufferPool */4].length
                                              ]), /* tuple */[
                                            0,
                                            0
                                          ]);
                              }));
                        return Wonder_jest.test("else, add buffer to pool", (function () {
                                      var match = _prepare(state[0]);
                                      var match$1 = match[1];
                                      var state$1 = GameObject$Wonderjs.batchDisposeGameObject(/* int array */[
                                            match$1[0],
                                            match$1[2]
                                          ], match[0]);
                                      var match$2 = VboBufferTool$Wonderjs.getVboBufferData(state$1);
                                      return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                                      match$2[/* vertexArrayBufferPool */3].length,
                                                      match$2[/* elementArrayBufferPool */4].length
                                                    ]), /* tuple */[
                                                  1,
                                                  1
                                                ]);
                                    }));
                      }));
                return Wonder_jest.test("shared geometry should share one buffer", (function () {
                              var match = _prepare(state[0]);
                              var match$1 = match[2];
                              return Curry._2(Wonder_jest.Expect[/* Operators */23][/* = */5], Wonder_jest.Expect[/* expect */0](/* tuple */[
                                              Sinon.getCallCount(match$1[0]),
                                              match$1[7],
                                              match$1[8]
                                            ]), /* tuple */[
                                          2,
                                          match$1[1],
                                          match$1[2]
                                        ]);
                            }));
              }));
        return /* () */0;
      }));

export {
  
}
/*  Not a pure module */
