// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Js_option                      from "../../../../../node_modules/bs-platform/lib/es6/js_option.js";
import * as Caml_array                     from "../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Log$WonderLog                  from "../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog             from "../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as StateData$Wonderjs             from "../../core/StateData.js";
import * as ArraySystem$Wonderjs           from "../../structure/ArraySystem.js";
import * as InstanceUtils$Wonderjs         from "../../renderer/utils/InstanceUtils.js";
import * as JobConfigSystem$Wonderjs       from "../common/JobConfigSystem.js";
import * as ArraySystem$WonderCommonlib    from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArraySystem.js";
import * as ExceptionHandleSystem$Wonderjs from "../../exception/ExceptionHandleSystem.js";

function _unsafeGetRenderJobConfig(state) {
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("render job config exist", "not"), (function () {
                        return Contract$WonderLog.assertExist(state[/* renderJobConfig */5]);
                      }));
        }), StateData$Wonderjs.stateData[/* isDebug */1]);
  return Js_option.getExn(state[/* renderJobConfig */5]);
}

function getInitPipelines(state) {
  return _unsafeGetRenderJobConfig(state)[/* init_pipelines */1];
}

function getInitJobs(state) {
  return _unsafeGetRenderJobConfig(state)[/* init_jobs */3];
}

function getRenderPipelines(state) {
  return _unsafeGetRenderJobConfig(state)[/* render_pipelines */2];
}

function getRenderJobs(state) {
  return _unsafeGetRenderJobConfig(state)[/* render_jobs */4];
}

function getShaders(state) {
  return _unsafeGetRenderJobConfig(state)[/* shaders */5];
}

function getShaderLibs(state) {
  return _unsafeGetRenderJobConfig(state)[/* shader_libs */6];
}

function getRenderSetting(state) {
  return _unsafeGetRenderJobConfig(state)[/* render_setting */0];
}

function _getExecutableJob(jobs, param) {
  var jobItemName = param[/* name */0];
  var match = JobConfigSystem$Wonderjs.findFirst(jobs, (function (param) {
          return JobConfigSystem$Wonderjs.filterTargetName(param[/* name */0], jobItemName);
        }));
  return /* record */[
          /* name */jobItemName,
          /* flags */param[/* flags */1],
          /* shader */match[/* shader */1]
        ];
}

function _getPipelineExecutableJobs(pipeline, pipelines, jobs) {
  var pipelineItem = JobConfigSystem$Wonderjs.findFirst(pipelines, (function (param) {
          return JobConfigSystem$Wonderjs.filterTargetName(param[/* name */0], pipeline);
        }));
  return pipelineItem[/* jobs */1].map((function (param) {
                return _getExecutableJob(jobs, param);
              }));
}

function getInitPipelineExecutableJobs(param, init_pipelines, jobs) {
  return _getPipelineExecutableJobs(param[/* init_pipeline */0], init_pipelines, jobs);
}

function getRenderPipelineExecutableJobs(param, render_pipelines, jobs) {
  return _getPipelineExecutableJobs(param[/* render_pipeline */1], render_pipelines, jobs);
}

function _findFirstShaderData(shaderLibName, shaderLibs) {
  return JobConfigSystem$Wonderjs.findFirst(shaderLibs, (function (item) {
                return JobConfigSystem$Wonderjs.filterTargetName(item[/* name */0], shaderLibName);
              }));
}

function _getMaterialShaderLibDataArrByGroup(groups, name, shaderLibs, resultDataArr) {
  return resultDataArr.concat(JobConfigSystem$Wonderjs.findFirst(groups, (function (item) {
                        return JobConfigSystem$Wonderjs.filterTargetName(item[/* name */0], name);
                      }))[/* value */1].map((function (name) {
                    return _findFirstShaderData(name, shaderLibs);
                  })));
}

function _getMaterialShaderLibDataArrByStaticBranchModelMatrixInstance(param, param$1, resultDataArr) {
  var value = param$1[1];
  var state = param[1];
  return ArraySystem$Wonderjs.push(_findFirstShaderData(InstanceUtils$Wonderjs.isSourceInstance(param[0], state) ? (
                    InstanceUtils$Wonderjs.isSupportInstance(state) ? Caml_array.caml_array_get(value, 1) : Caml_array.caml_array_get(value, 2)
                  ) : Caml_array.caml_array_get(value, 0), param$1[0]), resultDataArr);
}

function _getMaterialShaderLibDataArrByStaticBranch(param, param$1, resultDataArr) {
  var static_branchs = param$1[0];
  var name = param[1];
  if (name === "modelMatrix_instance") {
    var match = JobConfigSystem$Wonderjs.findFirst(static_branchs, (function (item) {
            return JobConfigSystem$Wonderjs.filterTargetName(item[/* name */0], name);
          }));
    return _getMaterialShaderLibDataArrByStaticBranchModelMatrixInstance(/* tuple */[
                param[0],
                param[2]
              ], /* tuple */[
                param$1[1],
                match[/* value */1]
              ], resultDataArr);
  } else {
    Log$WonderLog.debugJson((function () {
            var partial_arg = "static_branchs";
            return (function (param) {
                return Log$WonderLog.buildDebugJsonMessage(partial_arg, static_branchs, param);
              });
          }), StateData$Wonderjs.stateData[/* isDebug */1]);
    return Log$WonderLog.fatal(Log$WonderLog.buildFatalMessage("_getMaterialShaderLibDataArrByStaticBranch", "unknown name:" + (String(name) + ""), "", "", ""));
  }
}

function _getMaterialShaderLibDataArrByType(param, param$1, resultDataArr) {
  var shaderLibs = param$1[0];
  var name = param[2];
  var type_ = param[0];
  switch (type_) {
    case "group" : 
        return _getMaterialShaderLibDataArrByGroup(param[1], name, shaderLibs, resultDataArr);
    case "static_branch" : 
        return _getMaterialShaderLibDataArrByStaticBranch(/* tuple */[
                    param[3],
                    name,
                    param[4]
                  ], /* tuple */[
                    param$1[1],
                    shaderLibs
                  ], resultDataArr);
    default:
      Log$WonderLog.debugJson((function () {
              var partial_arg = "shaderLibs";
              return (function (param) {
                  return Log$WonderLog.buildDebugJsonMessage(partial_arg, shaderLibs, param);
                });
            }), StateData$Wonderjs.stateData[/* isDebug */1]);
      return Log$WonderLog.fatal(Log$WonderLog.buildFatalMessage("_getMaterialShaderLibDataArrByType", "unknown type_:" + (String(type_) + ""), "", "", ""));
  }
}

function getMaterialShaderLibDataArr(gameObject, param, state) {
  var shaderLibs = param[2];
  var match = param[0];
  var groups = match[/* groups */1];
  var static_branchs = match[/* static_branchs */0];
  return ArraySystem$WonderCommonlib.reduceOneParam((function (resultDataArr, param) {
                var name = param[/* name */1];
                var type_ = param[/* type_ */0];
                if (type_) {
                  return _getMaterialShaderLibDataArrByType(/* tuple */[
                              type_[0],
                              groups,
                              name,
                              gameObject,
                              state
                            ], /* tuple */[
                              shaderLibs,
                              static_branchs
                            ], resultDataArr);
                } else {
                  return ArraySystem$Wonderjs.push(_findFirstShaderData(name, shaderLibs), resultDataArr);
                }
              }), ArraySystem$WonderCommonlib.createEmpty(/* () */0), param[1]);
}

function throwJobFlagsShouldBeDefined() {
  return ExceptionHandleSystem$Wonderjs.throwMessage("jobFlags should be defined");
}

export {
  _unsafeGetRenderJobConfig                                     ,
  getInitPipelines                                              ,
  getInitJobs                                                   ,
  getRenderPipelines                                            ,
  getRenderJobs                                                 ,
  getShaders                                                    ,
  getShaderLibs                                                 ,
  getRenderSetting                                              ,
  _getExecutableJob                                             ,
  _getPipelineExecutableJobs                                    ,
  getInitPipelineExecutableJobs                                 ,
  getRenderPipelineExecutableJobs                               ,
  _findFirstShaderData                                          ,
  _getMaterialShaderLibDataArrByGroup                           ,
  _getMaterialShaderLibDataArrByStaticBranchModelMatrixInstance ,
  _getMaterialShaderLibDataArrByStaticBranch                    ,
  _getMaterialShaderLibDataArrByType                            ,
  getMaterialShaderLibDataArr                                   ,
  throwJobFlagsShouldBeDefined                                  ,
  
}
/* Log-WonderLog Not a pure module */
