// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Log$WonderLog                    from "../../../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog               from "../../../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as MainStateData$Wonderjs           from "../data/MainStateData.js";
import * as IsDebugMainService$Wonderjs      from "../state/IsDebugMainService.js";
import * as PoolVboBufferService$Wonderjs    from "../../../record/vboBuffer/PoolVboBufferService.js";
import * as TypeArrayPoolService$Wonderjs    from "../../../record/typeArrayPool/TypeArrayPoolService.js";
import * as SparseMapService$WonderCommonlib from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapService.js";

function createBuffer(gl, capacity, state) {
  var buffer = PoolVboBufferService$Wonderjs.getInstanceBuffer(gl, state[/* vboBufferRecord */30]);
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, capacity, gl.DYNAMIC_DRAW);
  return buffer;
}

function _getFloat32InstanceArraySize(capacity) {
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("capacity should be a multiplier of 4", "is " + (String(capacity) + "")), (function () {
                        return Contract$WonderLog.Operators[/* = */0](capacity % 4, 0);
                      }));
        }), IsDebugMainService$Wonderjs.getIsDebug(MainStateData$Wonderjs.stateData));
  return capacity / 4 | 0;
}

function _createMatrixFloat32Array(capacity) {
  return new Float32Array(_getFloat32InstanceArraySize(capacity));
}

function _getCapacity(sourceInstance, defaultCapacity, capacityMap) {
  var match = SparseMapService$WonderCommonlib.get(sourceInstance, capacityMap);
  if (match) {
    return match[0];
  } else {
    return defaultCapacity;
  }
}

function _setCapacity(sourceInstance, capacity, capacityMap) {
  SparseMapService$WonderCommonlib.set(sourceInstance, capacity, capacityMap);
  return capacityMap;
}

function getOrCreateBuffer(param, param$1, state) {
  var bufferMap = param$1[1];
  var sourceInstance = param[1];
  var match = SparseMapService$WonderCommonlib.get(sourceInstance, bufferMap);
  if (match) {
    return match[0];
  } else {
    var buffer = createBuffer(param[0], _getCapacity(sourceInstance, param[2], param$1[0]), state);
    SparseMapService$WonderCommonlib.set(sourceInstance, buffer, bufferMap);
    return buffer;
  }
}

function getOrCreateMatrixFloat32Array(sourceInstance, defaultCapacity, param, state) {
  var matrixFloat32ArrayMap = param[1];
  var capacity = _getCapacity(sourceInstance, defaultCapacity, param[0]);
  var match = SparseMapService$WonderCommonlib.get(sourceInstance, matrixFloat32ArrayMap);
  if (match) {
    return match[0];
  } else {
    var match$1 = TypeArrayPoolService$Wonderjs.getFloat32TypeArrayFromPool(capacity, state[/* typeArrayPoolRecord */32]);
    if (match$1) {
      return match$1[0];
    } else {
      var typeArr = new Float32Array(_getFloat32InstanceArraySize(capacity));
      SparseMapService$WonderCommonlib.set(sourceInstance, typeArr, matrixFloat32ArrayMap);
      return typeArr;
    }
  }
}

function setCapacityAndUpdateBufferTypeArray(param, param$1, param$2, state) {
  var capacityMap = param$2[2];
  var buffer = param$1[0];
  var capacity = param[2];
  var sourceInstance = param[1];
  var gl = param[0];
  var currentCapacity = _getCapacity(sourceInstance, param[3], capacityMap);
  var needIncreaseCapacity = /* false */0;
  while(currentCapacity < capacity) {
    currentCapacity = (currentCapacity << 1);
    needIncreaseCapacity = /* true */1;
  };
  if (needIncreaseCapacity) {
    _setCapacity(sourceInstance, currentCapacity, capacityMap);
    gl.deleteBuffer(buffer);
    var buffer$1 = createBuffer(gl, currentCapacity, state);
    SparseMapService$WonderCommonlib.set(sourceInstance, buffer$1, param$2[0]);
    var matrixFloat32Array = new Float32Array(_getFloat32InstanceArraySize(currentCapacity));
    SparseMapService$WonderCommonlib.set(sourceInstance, matrixFloat32Array, param$2[1]);
    return /* tuple */[
            buffer$1,
            matrixFloat32Array
          ];
  } else {
    return /* tuple */[
            buffer,
            param$1[1]
          ];
  }
}

function updateData(gl, record, buffer) {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, record);
  return buffer;
}

function bind(gl, buffer) {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  return buffer;
}

export {
  createBuffer                        ,
  _getFloat32InstanceArraySize        ,
  _createMatrixFloat32Array           ,
  _getCapacity                        ,
  _setCapacity                        ,
  getOrCreateBuffer                   ,
  getOrCreateMatrixFloat32Array       ,
  setCapacityAndUpdateBufferTypeArray ,
  updateData                          ,
  bind                                ,
  
}
/* Log-WonderLog Not a pure module */
