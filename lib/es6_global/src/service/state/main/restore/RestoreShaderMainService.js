// Generated by BUCKLESCRIPT VERSION 3.1.4, PLEASE EDIT WITH CARE

import * as Caml_array from "../../../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Log$WonderLog from "../../../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog from "../../../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as StateDataMain$Wonderjs from "../data/StateDataMain.js";
import * as HashMapService$Wonderjs from "../../../atom/HashMapService.js";
import * as IsDebugMainService$Wonderjs from "../state/IsDebugMainService.js";
import * as ArrayService$WonderCommonlib from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArrayService.js";
import * as HashMapService$WonderCommonlib from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/HashMapService.js";

function _getIntersectShaderIndexMap(currentShaderIndexMap, targetShaderIndexMap) {
  var intersectShaderIndexDataArr = HashMapService$Wonderjs.entries(targetShaderIndexMap).filter((function (param) {
          return HashMapService$WonderCommonlib.has(param[0], currentShaderIndexMap);
        }));
  return /* tuple */[
          intersectShaderIndexDataArr.length,
          ArrayService$WonderCommonlib.reduceOneParam((function (shaderMap, param) {
                  return HashMapService$WonderCommonlib.set(param[0], param[1], shaderMap);
                }), HashMapService$WonderCommonlib.createEmpty(/* () */0), intersectShaderIndexDataArr)
        ];
}

function restore(currentState, targetState) {
  Contract$WonderLog.requireCheck((function () {
          var currentPrecision = currentState[/* glslRecord */27][/* precision */0];
          var targetPrecision = targetState[/* glslRecord */27][/* precision */0];
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("currentState->shaderRecord->glslRecord->precision and targetState ->shaderRecord->glslRecord->precision be the same", "not"), (function () {
                        if (currentPrecision) {
                          if (targetPrecision) {
                            return Contract$WonderLog.Operators[/* ==^ */2](currentPrecision[0], targetPrecision[0]);
                          } else {
                            return Contract$WonderLog.assertFail(/* () */0);
                          }
                        } else if (targetPrecision) {
                          return Contract$WonderLog.assertFail(/* () */0);
                        } else {
                          return Contract$WonderLog.assertPass(/* () */0);
                        }
                      }));
        }), IsDebugMainService$Wonderjs.getIsDebug(StateDataMain$Wonderjs.stateData));
  var match = currentState[/* shaderRecord */26];
  var currentShaderIndexMap = match[/* shaderIndexMap */1];
  var targetShaderData = targetState[/* shaderRecord */26];
  var targetShaderIndexMap = targetShaderData[/* shaderIndexMap */1];
  var match$1 = _getIntersectShaderIndexMap(currentShaderIndexMap, targetShaderIndexMap);
  var newrecord = Caml_array.caml_array_dup(targetState);
  newrecord[/* shaderRecord */26] = /* record */[
    /* index */match$1[0],
    /* shaderIndexMap */match$1[1]
  ];
  return newrecord;
}

export {
  _getIntersectShaderIndexMap ,
  restore ,
  
}
/* Log-WonderLog Not a pure module */
