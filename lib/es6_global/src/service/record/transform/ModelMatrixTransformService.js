// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Log$WonderLog                     from "../../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog                from "../../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as MainStateData$Wonderjs            from "../../state/main/data/MainStateData.js";
import * as Matrix3Service$Wonderjs           from "../../atom/Matrix3Service.js";
import * as Matrix4Service$Wonderjs           from "../../atom/Matrix4Service.js";
import * as Vector3Service$Wonderjs           from "../../atom/Vector3Service.js";
import * as GlobalTempService$Wonderjs        from "../globalTemp/GlobalTempService.js";
import * as IsDebugMainService$Wonderjs       from "../../state/main/state/IsDebugMainService.js";
import * as SparseMapService$WonderCommonlib  from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapService.js";
import * as HierachyTransformService$Wonderjs from "./HierachyTransformService.js";

function getLocalToWorldMatrixTypeArray(transform, param) {
  return Contract$WonderLog.ensureCheck((function (localToWorldMatrix) {
                return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("localToWorldMatrix exist", "not"), (function () {
                              return Contract$WonderLog.assertNullableExist(localToWorldMatrix);
                            }));
              }), IsDebugMainService$Wonderjs.getIsDebug(MainStateData$Wonderjs.stateData), SparseMapService$WonderCommonlib.unsafeGet(transform, param[/* localToWorldMatrixMap */4]));
}

function getNormalMatrixTypeArray(transform, record) {
  var normalMatrixCacheMap = record[/* normalMatrixCacheMap */7];
  var match = SparseMapService$WonderCommonlib.get(transform, normalMatrixCacheMap);
  if (match) {
    return /* tuple */[
            match[0],
            normalMatrixCacheMap
          ];
  } else {
    var normalMatrix = Matrix3Service$Wonderjs.transposeSelf(Matrix4Service$Wonderjs.invertTo3x3(getLocalToWorldMatrixTypeArray(transform, record), Matrix3Service$Wonderjs.createIdentityMatrix3(/* () */0)));
    return /* tuple */[
            normalMatrix,
            SparseMapService$WonderCommonlib.set(transform, normalMatrix, normalMatrixCacheMap)
          ];
  }
}

function getLocalPositionTypeArray(transform, localPositionMap) {
  return Contract$WonderLog.ensureCheck((function (localPosition) {
                return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("localPosition exist", "not"), (function () {
                              return Contract$WonderLog.assertNullableExist(localPosition);
                            }));
              }), IsDebugMainService$Wonderjs.getIsDebug(MainStateData$Wonderjs.stateData), SparseMapService$WonderCommonlib.unsafeGet(transform, localPositionMap));
}

function getLocalPositionTuple(transform, localPositionMap) {
  var typeArr = getLocalPositionTypeArray(transform, localPositionMap);
  return /* tuple */[
          typeArr[0],
          typeArr[1],
          typeArr[2]
        ];
}

function setLocalPositionByTuple(transform, param, record) {
  var typeArr = getLocalPositionTypeArray(transform, record[/* localPositionMap */5]);
  typeArr[0] = param[0];
  typeArr[1] = param[1];
  typeArr[2] = param[2];
  return HierachyTransformService$Wonderjs.markHierachyDirty(transform, record);
}

function setPositionByTuple(transform, parent, position, param) {
  var record = param[1];
  return setLocalPositionByTuple(transform, Vector3Service$Wonderjs.transformMat4Tuple(position, Matrix4Service$Wonderjs.invert(getLocalToWorldMatrixTypeArray(parent, record), GlobalTempService$Wonderjs.getFloat32Array1(param[0]))), record);
}

export {
  getLocalToWorldMatrixTypeArray ,
  getNormalMatrixTypeArray       ,
  getLocalPositionTypeArray      ,
  getLocalPositionTuple          ,
  setLocalPositionByTuple        ,
  setPositionByTuple             ,
  
}
/* Log-WonderLog Not a pure module */
