// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Caml_array                       from "../../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Caml_int32                       from "../../../../../../node_modules/bs-platform/lib/es6/caml_int32.js";
import * as Contract$WonderLog               from "../../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as MainStateData$Wonderjs           from "../../state/main/data/MainStateData.js";
import * as IsDebugMainService$Wonderjs      from "../../state/main/state/IsDebugMainService.js";
import * as MappedIndexService$Wonderjs      from "../../primitiive/MappedIndexService.js";
import * as ArrayService$WonderCommonlib     from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArrayService.js";
import * as DisposeComponentService$Wonderjs from "../../primitiive/component/DisposeComponentService.js";

function isAlive(light, mappedIndexMap) {
  return 1 - MappedIndexService$Wonderjs.isDisposed(MappedIndexService$Wonderjs.getMappedIndex(light, mappedIndexMap));
}

function deleteBySwapAndResetFloat32TypeArr(param, typeArr, length, defaultValueArr) {
  var targetIndex = param[1];
  var sourceIndex = param[0];
  for(var i = 0 ,i_finish = length - 1 | 0; i <= i_finish; ++i){
    typeArr[sourceIndex + i | 0] = typeArr[targetIndex + i | 0];
    typeArr[targetIndex + i | 0] = Caml_array.caml_array_get(defaultValueArr, i);
  }
  return typeArr;
}

function deleteSingleValueBySwapAndResetFloat32TypeArr(param, typeArr, _, defaultValue) {
  var targetIndex = param[1];
  typeArr[param[0]] = typeArr[targetIndex];
  typeArr[targetIndex] = defaultValue;
  return typeArr;
}

function deleteSingleValueBySwapAndResetUint8TypeArr(sourceIndex, lastIndex, typeArr, defaultValue) {
  typeArr[sourceIndex] = typeArr[lastIndex];
  typeArr[lastIndex] = defaultValue;
  return typeArr;
}

var disposeData = DisposeComponentService$Wonderjs.disposeSparseMapData;

function _swapIndex(mappedSourceIndex, lastComponentIndex, mappedIndexMap) {
  var match = +(mappedSourceIndex >= lastComponentIndex);
  if (match !== 0) {
    return mappedIndexMap;
  } else {
    return MappedIndexService$Wonderjs.setMappedIndex(lastComponentIndex, mappedSourceIndex, mappedIndexMap);
  }
}

function swapData(param, param$1, deleteBySwapAndResetTypeArrFunc, typeArr) {
  var dataSize = param$1[1];
  var lastComponentIndex = param[1];
  var mappedSourceIndex = param[0];
  var match = +(mappedSourceIndex >= lastComponentIndex);
  if (match !== 0) {
    return typeArr;
  } else {
    return deleteBySwapAndResetTypeArrFunc(/* tuple */[
                Caml_int32.imul(mappedSourceIndex, dataSize),
                Caml_int32.imul(lastComponentIndex, dataSize)
              ], typeArr, dataSize, param$1[2]);
  }
}

function setMappedIndexMap(sourceIndex, mappedSourceIndex, lastComponentIndex, mappedIndexMap) {
  return MappedIndexService$Wonderjs.markDisposed(sourceIndex, _swapIndex(mappedSourceIndex, lastComponentIndex, mappedIndexMap));
}

function handleDisposeComponent(light, param, record) {
  var isAliveFunc = param[0];
  Contract$WonderLog.requireCheck((function () {
          return DisposeComponentService$Wonderjs.checkComponentShouldAlive(light, isAliveFunc, record);
        }), IsDebugMainService$Wonderjs.getIsDebug(MainStateData$Wonderjs.stateData));
  return param[1](light, record);
}

function handleBatchDisposeComponent(lightArray, param, record) {
  var handleDisposeFunc = param[1];
  var isAliveFunc = param[0];
  Contract$WonderLog.requireCheck((function () {
          return DisposeComponentService$Wonderjs.checkComponentShouldAliveWithBatchDispose(lightArray, isAliveFunc, record);
        }), IsDebugMainService$Wonderjs.getIsDebug(MainStateData$Wonderjs.stateData));
  return ArrayService$WonderCommonlib.reduceOneParam((function (record, light) {
                return handleDisposeFunc(light, record);
              }), record, lightArray);
}

export {
  isAlive                                       ,
  deleteBySwapAndResetFloat32TypeArr            ,
  deleteSingleValueBySwapAndResetFloat32TypeArr ,
  deleteSingleValueBySwapAndResetUint8TypeArr   ,
  disposeData                                   ,
  _swapIndex                                    ,
  swapData                                      ,
  setMappedIndexMap                             ,
  handleDisposeComponent                        ,
  handleBatchDisposeComponent                   ,
  
}
/* Contract-WonderLog Not a pure module */
