// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Js_option                   from "../../../../../../../node_modules/bs-platform/lib/es6/js_option.js";
import * as Log$WonderLog               from "../../../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog          from "../../../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as OptionService$Wonderjs      from "../../../atom/OptionService.js";
import * as StateDataMain$Wonderjs      from "../../../state/main/data/StateDataMain.js";
import * as IsDebugMainService$Wonderjs from "../../../state/main/state/IsDebugMainService.js";

function _getExtension(name, gl) {
  var tmp = name === "instanced_arrays" ? gl.getExtension("ANGLE_instanced_arrays") : gl.getExtension(name);
  if (tmp == null) {
    return /* None */0;
  } else {
    return [tmp];
  }
}

function _detectExtension(gl, record) {
  return /* record */[
          /* extensionInstancedArrays */_getExtension("instanced_arrays", gl),
          /* precision */record[/* precision */1]
        ];
}

function _detectPrecision(gl, record) {
  var vertexShader = gl.VERTEX_SHADER;
  var fragmentShader = gl.FRAGMENT_SHADER;
  var highFloat = gl.HIGH_FLOAT;
  var mediumFloat = gl.MEDIUM_FLOAT;
  var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(vertexShader, highFloat);
  var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(vertexShader, mediumFloat);
  var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(fragmentShader, highFloat);
  var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(fragmentShader, mediumFloat);
  var highpAvailable = +(vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0);
  var mediumpAvailable = +(vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0);
  if (highpAvailable) {
    return /* record */[
            /* extensionInstancedArrays */record[/* extensionInstancedArrays */0],
            /* precision : Some */[/* HIGHP */0]
          ];
  } else if (mediumpAvailable) {
    Log$WonderLog.warn("not support highp, using mediump instead");
    return /* record */[
            /* extensionInstancedArrays */record[/* extensionInstancedArrays */0],
            /* precision : Some */[/* MEDIUMP */1]
          ];
  } else {
    Log$WonderLog.warn("not support highp and mediump, using lowp instead");
    return /* record */[
            /* extensionInstancedArrays */record[/* extensionInstancedArrays */0],
            /* precision : Some */[/* LOWP */2]
          ];
  }
}

var _detectCapabilty = _detectPrecision;

function detect(gl, record) {
  return _detectPrecision(gl, _detectExtension(gl, record));
}

var hasExtension = Js_option.isSome;

function unsafeGetInstanceExtension(record) {
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("extensionInstancedArrays exist", "not"), (function () {
                        return Contract$WonderLog.assertExist(record[/* extensionInstancedArrays */0]);
                      }));
        }), IsDebugMainService$Wonderjs.getIsDebug(StateDataMain$Wonderjs.stateData));
  return OptionService$Wonderjs.unsafeGet(record[/* extensionInstancedArrays */0]);
}

export {
  _getExtension              ,
  _detectExtension           ,
  _detectPrecision           ,
  _detectCapabilty           ,
  detect                     ,
  hasExtension               ,
  unsafeGetInstanceExtension ,
  
}
/* Log-WonderLog Not a pure module */
