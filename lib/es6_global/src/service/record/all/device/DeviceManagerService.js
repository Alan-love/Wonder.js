// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Log$WonderLog               from "../../../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog          from "../../../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as OptionService$Wonderjs      from "../../../atom/OptionService.js";
import * as StateDataMain$Wonderjs      from "../../../state/main/data/StateDataMain.js";
import * as IsDebugMainService$Wonderjs from "../../../state/main/state/IsDebugMainService.js";

function unsafeGetGl(record) {
  var gl = record[/* gl */0];
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("gl exist", "not"), (function () {
                        return Contract$WonderLog.assertExist(gl);
                      }));
        }), IsDebugMainService$Wonderjs.getIsDebug(StateDataMain$Wonderjs.stateData));
  return OptionService$Wonderjs.unsafeGet(gl);
}

function setGl(gl, record) {
  var newrecord = record.slice();
  newrecord[/* gl */0] = /* Some */[gl];
  return newrecord;
}

function setColorWrite(gl, param, record) {
  var colorWrite = record[/* colorWrite */1];
  var writeAlpha = param[3];
  var writeBlue = param[2];
  var writeGreen = param[1];
  var writeRed = param[0];
  var exit = 0;
  if (colorWrite) {
    var match = colorWrite[0];
    if (match[0] === writeRed && match[1] === writeGreen && match[2] === writeBlue && match[3] === writeAlpha) {
      return record;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
    var newrecord = record.slice();
    newrecord[/* colorWrite */1] = /* Some */[/* tuple */[
        writeRed,
        writeGreen,
        writeBlue,
        writeAlpha
      ]];
    return newrecord;
  }
  
}

function _setSide(gl, targetSide) {
  switch (targetSide) {
    case 0 : 
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.FRONT_AND_BACK);
        return /* () */0;
    case 1 : 
        gl.disable(gl.CULL_FACE);
        return /* () */0;
    case 2 : 
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        return /* () */0;
    case 3 : 
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.FRONT);
        return /* () */0;
    
  }
}

function setSide(gl, targetSide, record) {
  var side = record[/* side */3];
  var exit = 0;
  if (side) {
    if (side[0] === targetSide) {
      return record;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    _setSide(gl, targetSide);
    var newrecord = record.slice();
    newrecord[/* side */3] = /* Some */[targetSide];
    return newrecord;
  }
  
}

function setDepthTest(gl, targetDepthTest, record) {
  var depthTest = record[/* depthTest */4];
  var exit = 0;
  if (depthTest) {
    if (depthTest[0] === targetDepthTest) {
      return record;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (targetDepthTest !== 0) {
      gl.enable(gl.DEPTH_TEST);
    } else {
      gl.disable(gl.DEPTH_TEST);
    }
    var newrecord = record.slice();
    newrecord[/* depthTest */4] = /* Some */[targetDepthTest];
    return newrecord;
  }
  
}

function clearBuffer(gl, bit, record) {
  var record$1 = setColorWrite(gl, /* tuple */[
        true,
        true,
        true,
        true
      ], record);
  gl.clear(bit);
  return record$1;
}

function clearColor(gl, param, record) {
  var clearColor$1 = record[/* clearColor */2];
  var a = param[3];
  var b = param[2];
  var g = param[1];
  var r = param[0];
  var exit = 0;
  if (clearColor$1) {
    var match = clearColor$1[0];
    if (match[0] === r && match[1] === g && match[2] === b && match[3] === a) {
      return record;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    gl.clearColor(r, g, b, a);
    var newrecord = record.slice();
    newrecord[/* clearColor */2] = /* Some */[/* tuple */[
        r,
        g,
        b,
        a
      ]];
    return newrecord;
  }
  
}

function setViewportData(param, record) {
  var newrecord = record.slice();
  newrecord[/* viewport */5] = /* Some */[/* tuple */[
      param[0],
      param[1],
      param[2],
      param[3]
    ]];
  return newrecord;
}

function setViewportOfGl(gl, param, record) {
  var viewport = record[/* viewport */5];
  var height = param[3];
  var width = param[2];
  var y = param[1];
  var x = param[0];
  var exit = 0;
  if (viewport) {
    var match = viewport[0];
    if (match[0] === x && match[1] === y && match[2] === width && match[3] === height) {
      return record;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    gl.viewport(x, y, width, height);
    var newrecord = record.slice();
    newrecord[/* viewport */5] = /* Some */[/* tuple */[
        x,
        y,
        width,
        height
      ]];
    return newrecord;
  }
  
}

export {
  unsafeGetGl     ,
  setGl           ,
  setColorWrite   ,
  _setSide        ,
  setSide         ,
  setDepthTest    ,
  clearBuffer     ,
  clearColor      ,
  setViewportData ,
  setViewportOfGl ,
  
}
/* Log-WonderLog Not a pure module */
