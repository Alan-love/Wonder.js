// Generated by BUCKLESCRIPT VERSION 3.1.4, PLEASE EDIT WITH CARE

import * as Curry from "../../../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Caml_array from "../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Caml_int32 from "../../../../../node_modules/bs-platform/lib/es6/caml_int32.js";
import * as Log$WonderLog from "../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog from "../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as ArrayService$Wonderjs from "../../service/atom/ArrayService.js";
import * as StateDataMain$Wonderjs from "../../service/state/main/data/StateDataMain.js";
import * as AssembleCommon$Wonderjs from "./AssembleCommon.js";
import * as DataViewCommon$Wonderjs from "../generate/DataViewCommon.js";
import * as IsDebugMainService$Wonderjs from "../../service/state/main/state/IsDebugMainService.js";
import * as ArrayService$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArrayService.js";
import * as BatchOperateLightSystem$Wonderjs from "./BatchOperateLightSystem.js";
import * as NameGameObjectMainService$Wonderjs from "../../service/state/main/gameObject/NameGameObjectMainService.js";
import * as RecordTransformMainService$Wonderjs from "../../service/state/main/transform/RecordTransformMainService.js";
import * as BatchSetTextureAllDataSystem$Wonderjs from "./BatchSetTextureAllDataSystem.js";
import * as NameLightMaterialMainService$Wonderjs from "../../service/state/main/material/light/NameLightMaterialMainService.js";
import * as OperateLightMaterialMainService$Wonderjs from "../../service/state/main/material/light/OperateLightMaterialMainService.js";
import * as IndicesCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/IndicesCustomGeometryMainService.js";
import * as NormalsCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/NormalsCustomGeometryMainService.js";
import * as OperateTypeArrayTransformService$Wonderjs from "../../service/record/main/transform/OperateTypeArrayTransformService.js";
import * as NameBasicSourceTextureMainService$Wonderjs from "../../service/state/main/texture/basic_source/NameBasicSourceTextureMainService.js";
import * as VerticesCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/VerticesCustomGeometryMainService.js";
import * as TexCoordsCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/TexCoordsCustomGeometryMainService.js";
import * as BatchAddGameObjectComponentMainService$Wonderjs from "../../service/state/main/gameObject/BatchAddGameObjectComponentMainService.js";
import * as FrustumPerspectiveCameraProjectionService$Wonderjs from "../../service/record/main/perspective_camera_projection/FrustumPerspectiveCameraProjectionService.js";

function _getBatchArrByIndices(sourceArr, indices) {
  return indices.map((function (index) {
                return sourceArr[index];
              }));
}

function _batchCreateMeshRendererArr(lightMaterialGameObjects, _, state) {
  var meshRendererRecord = state[/* meshRendererRecord */24];
  AssembleCommon$Wonderjs.checkNotDisposedBefore(meshRendererRecord[/* disposedIndexArray */4]);
  var index = meshRendererRecord[/* index */0];
  var newIndex = index + lightMaterialGameObjects.length | 0;
  var indexArr = ArrayService$Wonderjs.range(index, newIndex - 1 | 0);
  state[/* meshRendererRecord */24] = /* record */[
    /* index */newIndex,
    /* basicMaterialRenderGameObjectArray */meshRendererRecord[/* basicMaterialRenderGameObjectArray */1],
    /* lightMaterialRenderGameObjectArray */meshRendererRecord[/* lightMaterialRenderGameObjectArray */2],
    /* gameObjectMap */meshRendererRecord[/* gameObjectMap */3],
    /* disposedIndexArray */meshRendererRecord[/* disposedIndexArray */4]
  ];
  return /* tuple */[
          state,
          indexArr
        ];
}

function _getBatchComponentGameObjectData(param, indices, wdRecord, state) {
  var transformArr = param[1];
  var gameObjectArr = param[0];
  var parentTransforms = _getBatchArrByIndices(transformArr, indices[/* gameObjectIndices */0][/* childrenTransformIndexData */0][/* parentTransformIndices */0]);
  var childrenTransforms = indices[/* gameObjectIndices */0][/* childrenTransformIndexData */0][/* childrenTransformIndices */1].map((function (childrenIndices) {
          return childrenIndices.map((function (index) {
                        return transformArr[index];
                      }));
        }));
  var transformGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* transformGameObjectIndexData */1][/* gameObjectIndices */0]);
  var gameObjectTransforms = _getBatchArrByIndices(transformArr, indices[/* gameObjectIndices */0][/* transformGameObjectIndexData */1][/* componentIndices */1]);
  var customGeometryGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* customGeometryGameObjectIndexData */7][/* gameObjectIndices */0]);
  var gameObjectCustomGeometrys = _getBatchArrByIndices(param[2], indices[/* gameObjectIndices */0][/* customGeometryGameObjectIndexData */7][/* componentIndices */1]);
  var lightMaterialGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* lightMaterialGameObjectIndexData */4][/* gameObjectIndices */0]);
  var gameObjectLightMaterials = _getBatchArrByIndices(param[5], indices[/* gameObjectIndices */0][/* lightMaterialGameObjectIndexData */4][/* componentIndices */1]);
  var match = _batchCreateMeshRendererArr(lightMaterialGameObjects, wdRecord, state);
  return /* tuple */[
          /* tuple */[
            parentTransforms,
            childrenTransforms,
            transformGameObjects,
            gameObjectTransforms,
            customGeometryGameObjects,
            gameObjectCustomGeometrys,
            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* basicCameraViewGameObjectIndexData */2][/* gameObjectIndices */0]),
            _getBatchArrByIndices(param[3], indices[/* gameObjectIndices */0][/* basicCameraViewGameObjectIndexData */2][/* componentIndices */1]),
            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* perspectiveCameraProjectionGameObjectIndexData */3][/* gameObjectIndices */0]),
            _getBatchArrByIndices(param[4], indices[/* gameObjectIndices */0][/* perspectiveCameraProjectionGameObjectIndexData */3][/* componentIndices */1]),
            lightMaterialGameObjects,
            gameObjectLightMaterials,
            lightMaterialGameObjects,
            match[1],
            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* directionLightGameObjectIndexData */5][/* gameObjectIndices */0]),
            _getBatchArrByIndices(param[6], indices[/* gameObjectIndices */0][/* directionLightGameObjectIndexData */5][/* componentIndices */1]),
            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* pointLightGameObjectIndexData */6][/* gameObjectIndices */0]),
            _getBatchArrByIndices(param[7], indices[/* gameObjectIndices */0][/* pointLightGameObjectIndexData */6][/* componentIndices */1])
          ],
          match[0]
        ];
}

function _getBatchTextureData(lightMaterialArr, basicSourceTextureArr, imageArr, param) {
  var indices = param[/* indices */2];
  return /* tuple */[
          /* tuple */[
            _getBatchArrByIndices(lightMaterialArr, indices[/* materialIndices */1][/* diffuseMapMaterialIndices */0][/* materialIndices */0]),
            _getBatchArrByIndices(basicSourceTextureArr, indices[/* materialIndices */1][/* diffuseMapMaterialIndices */0][/* mapIndices */1])
          ],
          /* tuple */[
            _getBatchArrByIndices(basicSourceTextureArr, indices[/* samplerTextureIndices */3][/* textureIndices */0]),
            _getBatchArrByIndices(param[/* samplers */6], indices[/* samplerTextureIndices */3][/* samplerIndices */1])
          ],
          /* tuple */[
            _getBatchArrByIndices(basicSourceTextureArr, indices[/* imageTextureIndices */2][/* textureIndices */0]),
            _getBatchArrByIndices(imageArr, indices[/* imageTextureIndices */2][/* imageIndices */1])
          ]
        ];
}

function _getAccessorTypeSize(param) {
  switch (param[/* type_ */4]) {
    case 0 : 
        return 1;
    case 1 : 
        return 2;
    case 2 : 
        return 3;
    case 3 : 
    case 4 : 
        return 4;
    case 5 : 
        return 9;
    case 6 : 
        return 16;
    
  }
}

function _getBufferData(param, param$1, param$2) {
  var getDataViewFunc = param$2[0];
  var bytes_per_element = param$1[2];
  var accessorIndex = param$1[0];
  var accessors = param[/* accessors */9];
  var bufferViews = param[/* bufferViews */8];
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("not support interleaved buffer data", "is interleaved"), (function () {
                        var accessor = accessors[accessorIndex];
                        var bufferView = bufferViews[accessor[/* bufferView */0]];
                        var match = bufferView[/* byteStride */3];
                        if (match) {
                          return Contract$WonderLog.Operators[/* = */0](match[0], Caml_int32.imul(_getAccessorTypeSize(accessor), bytes_per_element));
                        } else {
                          return /* () */0;
                        }
                      }));
        }), IsDebugMainService$Wonderjs.getIsDebug(StateDataMain$Wonderjs.stateData));
  var accessor = accessors[accessorIndex];
  var bufferView = bufferViews[accessor[/* bufferView */0]];
  var dataView = param$1[1][bufferView[/* buffer */0]];
  var offset = accessor[/* byteOffset */1] + bufferView[/* byteOffset */1] | 0;
  var pointArr = /* array */[];
  for(var i = 0 ,i_finish = Caml_int32.imul(accessor[/* count */2], _getAccessorTypeSize(accessor)) - 1 | 0; i <= i_finish; ++i){
    var match = getDataViewFunc(offset, dataView);
    offset = match[1];
    ArrayService$Wonderjs.push(match[0], pointArr);
  }
  return Curry._1(param$2[1], pointArr);
}

function _getBufferAttributeData(accessorIndex, dataViewArr, wdRecord) {
  return _getBufferData(wdRecord, /* tuple */[
              accessorIndex,
              dataViewArr,
              Float32Array.BYTES_PER_ELEMENT
            ], /* tuple */[
              DataViewCommon$Wonderjs.getFloat,
              (function (prim) {
                  return new Float32Array(prim);
                })
            ]);
}

function _getBufferIndexData(accessorIndex, dataViewArr, wdRecord) {
  return _getBufferData(wdRecord, /* tuple */[
              accessorIndex,
              dataViewArr,
              Uint16Array.BYTES_PER_ELEMENT
            ], /* tuple */[
              DataViewCommon$Wonderjs.getUint16_1,
              (function (prim) {
                  return new Uint16Array(prim);
                })
            ]);
}

function _batchSetCustomGeometryData(wdRecord, customGeometryArr, bufferArr, state) {
  var dataViewArr = bufferArr.map(DataViewCommon$Wonderjs.create);
  return ArrayService$WonderCommonlib.reduceOneParami((function (state, geometryData, geometryIndex) {
                if (geometryData) {
                  var match = geometryData[0];
                  var texCoord = match[/* texCoord */2];
                  var normal = match[/* normal */1];
                  var customGeometry = customGeometryArr[geometryIndex];
                  var state$1 = VerticesCustomGeometryMainService$Wonderjs.setVerticesByTypeArray(customGeometry, _getBufferAttributeData(match[/* position */0], dataViewArr, wdRecord), state);
                  var state$2 = normal ? NormalsCustomGeometryMainService$Wonderjs.setNormalsByTypeArray(customGeometry, _getBufferAttributeData(normal[0], dataViewArr, wdRecord), state$1) : state$1;
                  var state$3 = texCoord ? TexCoordsCustomGeometryMainService$Wonderjs.setTexCoordsByTypeArray(customGeometry, _getBufferAttributeData(texCoord[0], dataViewArr, wdRecord), state$2) : state$2;
                  return IndicesCustomGeometryMainService$Wonderjs.setIndicesByTypeArray(customGeometry, _getBufferIndexData(match[/* index */3], dataViewArr, wdRecord), state$3);
                } else {
                  return state;
                }
              }), state, wdRecord[/* customGeometrys */15]);
}

function _batchSetTransformParent(parentTransforms, childrenTransforms, state) {
  var transformRecord = RecordTransformMainService$Wonderjs.getRecord(state);
  var parentMap = transformRecord[/* parentMap */15];
  var childMap = transformRecord[/* childMap */16];
  var match = ArrayService$WonderCommonlib.reduceOneParami((function (hierachyDataTuple, parentTransform, index) {
          return AssembleCommon$Wonderjs.addChildrenToParent(parentTransform, childrenTransforms[index], hierachyDataTuple);
        }), /* tuple */[
        parentMap,
        childMap
      ], parentTransforms);
  var newrecord = Caml_array.caml_array_dup(state);
  var newrecord$1 = Caml_array.caml_array_dup(transformRecord);
  newrecord[/* transformRecord */11] = /* Some */[(newrecord$1[/* parentMap */15] = match[0], newrecord$1[/* childMap */16] = match[1], newrecord$1)];
  return newrecord;
}

function _batchSetTransformData(param, gameObjectTransforms, state) {
  var transforms = param[/* transforms */14];
  var transformRecord = RecordTransformMainService$Wonderjs.getRecord(state);
  var localPositions = transformRecord[/* localPositions */3];
  var localRotations = transformRecord[/* localRotations */4];
  var localScales = transformRecord[/* localScales */5];
  var newrecord = Caml_array.caml_array_dup(state);
  var newrecord$1 = Caml_array.caml_array_dup(transformRecord);
  newrecord[/* transformRecord */11] = /* Some */[(newrecord$1[/* localPositions */3] = ArrayService$WonderCommonlib.reduceOneParami((function (localPositions, param, index) {
              var translation = param[/* translation */0];
              if (translation) {
                var transform = Caml_array.caml_array_get(gameObjectTransforms, index);
                return OperateTypeArrayTransformService$Wonderjs.setLocalPositionByTuple(transform, translation[0], localPositions);
              } else {
                return localPositions;
              }
            }), localPositions, transforms), newrecord$1[/* localRotations */4] = ArrayService$WonderCommonlib.reduceOneParami((function (localRotations, param, index) {
              var rotation = param[/* rotation */1];
              if (rotation) {
                var transform = Caml_array.caml_array_get(gameObjectTransforms, index);
                return OperateTypeArrayTransformService$Wonderjs.setLocalRotationByTuple(transform, rotation[0], localRotations);
              } else {
                return localRotations;
              }
            }), localRotations, transforms), newrecord$1[/* localScales */5] = ArrayService$WonderCommonlib.reduceOneParami((function (localScales, param, index) {
              var scale = param[/* scale */2];
              if (scale) {
                var transform = Caml_array.caml_array_get(gameObjectTransforms, index);
                return OperateTypeArrayTransformService$Wonderjs.setLocalScaleByTuple(transform, scale[0], localScales);
              } else {
                return localScales;
              }
            }), localScales, transforms), newrecord$1)];
  return newrecord;
}

function _batchSetPerspectiveCameraProjectionData(param, perspectiveCameraProjectionArr, state) {
  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */14];
  ArrayService$WonderCommonlib.reduceOneParami((function (perspectiveCameraProjectionRecord, param, index) {
          var aspect = param[/* aspect */3];
          var far = param[/* far */1];
          var cameraProjection = Caml_array.caml_array_get(perspectiveCameraProjectionArr, index);
          var perspectiveCameraProjectionRecord$1 = FrustumPerspectiveCameraProjectionService$Wonderjs.setNear(cameraProjection, param[/* near */0], perspectiveCameraProjectionRecord);
          var perspectiveCameraProjectionRecord$2 = far ? FrustumPerspectiveCameraProjectionService$Wonderjs.setFar(cameraProjection, far[0], perspectiveCameraProjectionRecord$1) : FrustumPerspectiveCameraProjectionService$Wonderjs.setFar(cameraProjection, FrustumPerspectiveCameraProjectionService$Wonderjs.getInfiniteFar(/* () */0), perspectiveCameraProjectionRecord$1);
          var perspectiveCameraProjectionRecord$3 = FrustumPerspectiveCameraProjectionService$Wonderjs.setFovy(cameraProjection, param[/* fovy */2], perspectiveCameraProjectionRecord$2);
          if (aspect) {
            return FrustumPerspectiveCameraProjectionService$Wonderjs.setAspect(cameraProjection, aspect[0], perspectiveCameraProjectionRecord$3);
          } else {
            return perspectiveCameraProjectionRecord$3;
          }
        }), perspectiveCameraProjectionRecord, param[/* perspectiveCameraProjections */13]);
  var newrecord = Caml_array.caml_array_dup(state);
  newrecord[/* perspectiveCameraProjectionRecord */14] = perspectiveCameraProjectionRecord;
  return newrecord;
}

function _batchSetLightMaterialData(param, lightMaterialArr, state) {
  return ArrayService$WonderCommonlib.reduceOneParami((function (state, param, index) {
                var material = Caml_array.caml_array_get(lightMaterialArr, index);
                return NameLightMaterialMainService$Wonderjs.setName(material, param[/* name */1], OperateLightMaterialMainService$Wonderjs.setDiffuseColor(material, param[/* diffuseColor */0], state));
              }), state, param[/* lightMaterials */16]);
}

function _batchSetName(targets, names, setNameFunc, state) {
  return ArrayService$WonderCommonlib.reduceOneParami((function (state, target, index) {
                return setNameFunc(target, names[index], state);
              }), state, targets);
}

function _batchSetNames(param, param$1, state) {
  return _batchSetName(param[1], param$1[1][/* names */1], NameBasicSourceTextureMainService$Wonderjs.setName, _batchSetName(param[0], param$1[0][/* names */1], NameGameObjectMainService$Wonderjs.setName, state));
}

function batchOperate(wdRecord, imageArr, bufferArr, param) {
  var basicSourceTextureArr = param[3];
  var match = param[2];
  var pointLightArr = match[6];
  var directionLightArr = match[5];
  var lightMaterialArr = match[4];
  var perspectiveCameraProjectionArr = match[3];
  var customGeometryArr = match[1];
  var gameObjectArr = param[1];
  var state = _batchSetNames(/* tuple */[
        gameObjectArr,
        basicSourceTextureArr
      ], /* tuple */[
        wdRecord[/* gameObjects */3],
        wdRecord[/* basicSourceTextures */5]
      ], param[0]);
  var match$1 = _getBatchComponentGameObjectData(/* tuple */[
        gameObjectArr,
        match[0],
        customGeometryArr,
        match[2],
        perspectiveCameraProjectionArr,
        lightMaterialArr,
        directionLightArr,
        pointLightArr
      ], wdRecord[/* indices */2], wdRecord, state);
  var match$2 = match$1[0];
  var gameObjectTransforms = match$2[3];
  var match$3 = _getBatchTextureData(lightMaterialArr, basicSourceTextureArr, imageArr, wdRecord);
  var match$4 = match$3[2];
  var match$5 = match$3[1];
  var match$6 = match$3[0];
  return /* tuple */[
          BatchSetTextureAllDataSystem$Wonderjs.batchSet(/* tuple */[
                match$6[0],
                match$6[1]
              ], /* tuple */[
                match$5[0],
                match$5[1]
              ], /* tuple */[
                match$4[0],
                match$4[1]
              ], BatchAddGameObjectComponentMainService$Wonderjs.batchAddPointLightComponentForCreate(match$2[16], match$2[17], BatchAddGameObjectComponentMainService$Wonderjs.batchAddDirectionLightComponentForCreate(match$2[14], match$2[15], BatchAddGameObjectComponentMainService$Wonderjs.batchAddMeshRendererComponentForCreate(match$2[12], match$2[13], BatchAddGameObjectComponentMainService$Wonderjs.batchAddLightMaterialComponentForCreate(match$2[10], match$2[11], BatchAddGameObjectComponentMainService$Wonderjs.batchAddPerspectiveCameraProjectionComponentForCreate(match$2[8], match$2[9], BatchAddGameObjectComponentMainService$Wonderjs.batchAddBasicCameraViewComponentForCreate(match$2[6], match$2[7], BatchAddGameObjectComponentMainService$Wonderjs.batchAddCustomGeometryComponentForCreate(match$2[4], match$2[5], BatchAddGameObjectComponentMainService$Wonderjs.batchAddTransformComponentForCreate(match$2[2], gameObjectTransforms, BatchOperateLightSystem$Wonderjs.setAmbientLightData(wdRecord, BatchOperateLightSystem$Wonderjs.batchSetPointLightData(wdRecord, pointLightArr, BatchOperateLightSystem$Wonderjs.batchSetDirectionLightData(wdRecord, directionLightArr, _batchSetLightMaterialData(wdRecord, lightMaterialArr, _batchSetPerspectiveCameraProjectionData(wdRecord, perspectiveCameraProjectionArr, _batchSetCustomGeometryData(wdRecord, customGeometryArr, bufferArr, _batchSetTransformParent(match$2[0], match$2[1], _batchSetTransformData(wdRecord, gameObjectTransforms, match$1[1]))))))))))))))))),
          gameObjectArr
        ];
}

export {
  _getBatchArrByIndices ,
  _batchCreateMeshRendererArr ,
  _getBatchComponentGameObjectData ,
  _getBatchTextureData ,
  _getAccessorTypeSize ,
  _getBufferData ,
  _getBufferAttributeData ,
  _getBufferIndexData ,
  _batchSetCustomGeometryData ,
  _batchSetTransformParent ,
  _batchSetTransformData ,
  _batchSetPerspectiveCameraProjectionData ,
  _batchSetLightMaterialData ,
  _batchSetName ,
  _batchSetNames ,
  batchOperate ,
  
}
/* Log-WonderLog Not a pure module */
