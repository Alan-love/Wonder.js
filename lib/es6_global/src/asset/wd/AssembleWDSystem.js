// Generated by BUCKLESCRIPT VERSION 3.1.4, PLEASE EDIT WITH CARE

import * as Caml_array from "../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Caml_int32 from "../../../../../node_modules/bs-platform/lib/es6/caml_int32.js";
import * as Log$WonderLog from "../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog from "../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as ArrayService$Wonderjs from "../../service/atom/ArrayService.js";
import * as BufferService$Wonderjs from "../../service/primitive/buffer/BufferService.js";
import * as StateDataMain$Wonderjs from "../../service/state/main/data/StateDataMain.js";
import * as Caml_builtin_exceptions from "../../../../../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as IsDebugMainService$Wonderjs from "../../service/state/main/state/IsDebugMainService.js";
import * as ArrayService$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArrayService.js";
import * as BufferSettingService$Wonderjs from "../../service/record/main/setting/BufferSettingService.js";
import * as DirtyTransformService$Wonderjs from "../../service/record/main/transform/DirtyTransformService.js";
import * as SparseMapService$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapService.js";
import * as RecordTransformMainService$Wonderjs from "../../service/state/main/transform/RecordTransformMainService.js";
import * as CreateGameObjectMainService$Wonderjs from "../../service/state/main/gameObject/CreateGameObjectMainService.js";
import * as GetComponentGameObjectService$Wonderjs from "../../service/record/main/gameObject/GetComponentGameObjectService.js";
import * as RecordCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/RecordCustomGeometryMainService.js";
import * as IndicesCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/IndicesCustomGeometryMainService.js";
import * as NormalsCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/NormalsCustomGeometryMainService.js";
import * as VerticesCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/VerticesCustomGeometryMainService.js";
import * as TexCoordsCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/TexCoordsCustomGeometryMainService.js";
import * as BatchAddGameObjectComponentMainService$Wonderjs from "../../service/state/main/gameObject/BatchAddGameObjectComponentMainService.js";

function _getAccessorTypeSize(param) {
  switch (param[/* type_ */4]) {
    case 0 : 
        return 1;
    case 1 : 
        return 2;
    case 2 : 
        return 3;
    case 3 : 
    case 4 : 
        return 4;
    case 5 : 
        return 9;
    case 6 : 
        return 16;
    
  }
}

function _getBufferAttributeData(accessorIndex, bufferArr, param) {
  var accessors = param[/* accessors */9];
  var bufferViews = param[/* bufferViews */8];
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("not support interleaved buffer data", "is interleaved"), (function () {
                        var accessor = accessors[accessorIndex];
                        var bufferView = bufferViews[accessor[/* bufferView */0]];
                        var match = bufferView[/* byteStride */3];
                        if (match) {
                          return Contract$WonderLog.Operators[/* = */0](match[0], Caml_int32.imul(_getAccessorTypeSize(accessor), Float32Array.BYTES_PER_ELEMENT));
                        } else {
                          throw [
                                Caml_builtin_exceptions.match_failure,
                                [
                                  "AssembleWDSystem.re",
                                  44,
                                  16
                                ]
                              ];
                        }
                      }));
        }), IsDebugMainService$Wonderjs.getIsDebug(StateDataMain$Wonderjs.stateData));
  var accessor = accessors[accessorIndex];
  var bufferView = bufferViews[accessor[/* bufferView */0]];
  return new Float32Array(bufferArr[bufferView[/* buffer */0]], accessor[/* byteOffset */1] + bufferView[/* byteOffset */1] | 0, Caml_int32.imul(accessor[/* count */2], _getAccessorTypeSize(accessor)));
}

function _getBufferIndexData(accessorIndex, bufferArr, param) {
  var accessors = param[/* accessors */9];
  var bufferViews = param[/* bufferViews */8];
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("not support interleaved buffer data", "is interleaved"), (function () {
                        var accessor = accessors[accessorIndex];
                        var bufferView = bufferViews[accessor[/* bufferView */0]];
                        var match = bufferView[/* byteStride */3];
                        if (match) {
                          return Contract$WonderLog.Operators[/* = */0](match[0], Caml_int32.imul(_getAccessorTypeSize(accessor), Uint16Array.BYTES_PER_ELEMENT));
                        } else {
                          return /* () */0;
                        }
                      }));
        }), IsDebugMainService$Wonderjs.getIsDebug(StateDataMain$Wonderjs.stateData));
  var accessor = accessors[accessorIndex];
  var bufferView = bufferViews[accessor[/* bufferView */0]];
  return new Uint16Array(bufferArr[bufferView[/* buffer */0]], accessor[/* byteOffset */1] + bufferView[/* byteOffset */1] | 0, Caml_int32.imul(accessor[/* count */2], _getAccessorTypeSize(accessor)));
}

function _batchSetCustomGeometryData(wdRecord, customGeometryArr, bufferArr, state) {
  return ArrayService$WonderCommonlib.reduceOneParami((function (state, geometryData, geometryIndex) {
                if (geometryData) {
                  var match = geometryData[0];
                  var texCoord = match[/* texCoord */2];
                  var normal = match[/* normal */1];
                  var customGeometry = customGeometryArr[geometryIndex];
                  var state$1 = VerticesCustomGeometryMainService$Wonderjs.setVerticesByTypeArray(customGeometry, _getBufferAttributeData(match[/* position */0], bufferArr, wdRecord), state);
                  var state$2 = normal ? NormalsCustomGeometryMainService$Wonderjs.setNormalsByTypeArray(customGeometry, _getBufferAttributeData(normal[0], bufferArr, wdRecord), state$1) : state$1;
                  var state$3 = texCoord ? TexCoordsCustomGeometryMainService$Wonderjs.setTexCoordsByTypeArray(customGeometry, _getBufferAttributeData(texCoord[0], bufferArr, wdRecord), state$2) : state$2;
                  return IndicesCustomGeometryMainService$Wonderjs.setIndicesByTypeArray(customGeometry, _getBufferIndexData(match[/* index */3], bufferArr, wdRecord), state$3);
                } else {
                  return state;
                }
              }), state, wdRecord[/* customGeometrys */13]);
}

function _checkNotExceedMaxCountByIndex(maxCount, indexArr) {
  BufferService$Wonderjs.checkNotExceedMaxCountByIndex(maxCount, indexArr[indexArr.length - 1 | 0]);
  return indexArr;
}

function _batchCreateCustomGeometry(param, state) {
  var customGeometryRecord = RecordCustomGeometryMainService$Wonderjs.getRecord(state);
  var index = customGeometryRecord[/* index */0];
  var newIndex = index + param[/* customGeometrys */13].length | 0;
  var indexArr = _checkNotExceedMaxCountByIndex(BufferSettingService$Wonderjs.getCustomGeometryCount(state[/* settingRecord */0]), ArrayService$Wonderjs.range(index, newIndex - 1 | 0));
  state[/* customGeometryRecord */24] = /* Some */[/* record */[
      /* index */newIndex,
      /* buffer */customGeometryRecord[/* buffer */1],
      /* vertices */customGeometryRecord[/* vertices */2],
      /* texCoords */customGeometryRecord[/* texCoords */3],
      /* normals */customGeometryRecord[/* normals */4],
      /* indices */customGeometryRecord[/* indices */5],
      /* verticesInfos */customGeometryRecord[/* verticesInfos */6],
      /* texCoordsInfos */customGeometryRecord[/* texCoordsInfos */7],
      /* normalsInfos */customGeometryRecord[/* normalsInfos */8],
      /* indicesInfos */customGeometryRecord[/* indicesInfos */9],
      /* verticesOffset */customGeometryRecord[/* verticesOffset */10],
      /* texCoordsOffset */customGeometryRecord[/* texCoordsOffset */11],
      /* normalsOffset */customGeometryRecord[/* normalsOffset */12],
      /* indicesOffset */customGeometryRecord[/* indicesOffset */13],
      /* disposeCount */customGeometryRecord[/* disposeCount */14],
      /* gameObjectMap */customGeometryRecord[/* gameObjectMap */15],
      /* groupCountMap */customGeometryRecord[/* groupCountMap */16],
      /* disposedIndexArray */customGeometryRecord[/* disposedIndexArray */17],
      /* disposedIndexMap */customGeometryRecord[/* disposedIndexMap */18],
      /* aliveIndexArray */customGeometryRecord[/* aliveIndexArray */19].concat(indexArr)
    ]];
  return /* tuple */[
          state,
          indexArr
        ];
}

function _addChildrenToParent(parent, children, param) {
  return /* tuple */[
          ArrayService$WonderCommonlib.reduceOneParam((function (parentMap, child) {
                  return SparseMapService$WonderCommonlib.set(child, parent, parentMap);
                }), param[0], children),
          SparseMapService$WonderCommonlib.set(parent, children, param[1])
        ];
}

function _batchSetTransformParent(parentTransforms, childrenTransforms, state) {
  var transformRecord = RecordTransformMainService$Wonderjs.getRecord(state);
  var parentMap = transformRecord[/* parentMap */9];
  var childMap = transformRecord[/* childMap */10];
  var match = ArrayService$WonderCommonlib.reduceOneParami((function (hierachyDataTuple, parentTransform, index) {
          return _addChildrenToParent(parentTransform, childrenTransforms[index], hierachyDataTuple);
        }), /* tuple */[
        parentMap,
        childMap
      ], parentTransforms);
  var newrecord = Caml_array.caml_array_dup(state);
  newrecord[/* transformRecord */11] = /* Some */[/* record */[
      /* index */transformRecord[/* index */0],
      /* buffer */transformRecord[/* buffer */1],
      /* localToWorldMatrices */transformRecord[/* localToWorldMatrices */2],
      /* localPositions */transformRecord[/* localPositions */3],
      /* copiedBuffer */transformRecord[/* copiedBuffer */4],
      /* copiedLocalToWorldMatrices */transformRecord[/* copiedLocalToWorldMatrices */5],
      /* copiedLocalPositions */transformRecord[/* copiedLocalPositions */6],
      /* defaultLocalToWorldMatrix */transformRecord[/* defaultLocalToWorldMatrix */7],
      /* defaultLocalPosition */transformRecord[/* defaultLocalPosition */8],
      /* parentMap */match[0],
      /* childMap */match[1],
      /* gameObjectMap */transformRecord[/* gameObjectMap */11],
      /* dirtyMap */transformRecord[/* dirtyMap */12],
      /* localToWorldMatrixCacheMap */transformRecord[/* localToWorldMatrixCacheMap */13],
      /* normalMatrixCacheMap */transformRecord[/* normalMatrixCacheMap */14],
      /* disposedIndexArray */transformRecord[/* disposedIndexArray */15]
    ]];
  return newrecord;
}

function _batchSetTransformData(param, gameObjectTransforms, state) {
  var transformRecord = RecordTransformMainService$Wonderjs.getRecord(state);
  var localPositions = transformRecord[/* localPositions */3];
  var newrecord = Caml_array.caml_array_dup(state);
  newrecord[/* transformRecord */11] = /* Some */[/* record */[
      /* index */transformRecord[/* index */0],
      /* buffer */transformRecord[/* buffer */1],
      /* localToWorldMatrices */transformRecord[/* localToWorldMatrices */2],
      /* localPositions */ArrayService$WonderCommonlib.reduceOneParami((function (localPositions, param, index) {
              var translation = param[/* translation */0];
              if (translation) {
                var transform = Caml_array.caml_array_get(gameObjectTransforms, index);
                return RecordTransformMainService$Wonderjs.setLocalPositionByTuple(transform, translation[0], localPositions);
              } else {
                return localPositions;
              }
            }), localPositions, param[/* transforms */12]),
      /* copiedBuffer */transformRecord[/* copiedBuffer */4],
      /* copiedLocalToWorldMatrices */transformRecord[/* copiedLocalToWorldMatrices */5],
      /* copiedLocalPositions */transformRecord[/* copiedLocalPositions */6],
      /* defaultLocalToWorldMatrix */transformRecord[/* defaultLocalToWorldMatrix */7],
      /* defaultLocalPosition */transformRecord[/* defaultLocalPosition */8],
      /* parentMap */transformRecord[/* parentMap */9],
      /* childMap */transformRecord[/* childMap */10],
      /* gameObjectMap */transformRecord[/* gameObjectMap */11],
      /* dirtyMap */transformRecord[/* dirtyMap */12],
      /* localToWorldMatrixCacheMap */transformRecord[/* localToWorldMatrixCacheMap */13],
      /* normalMatrixCacheMap */transformRecord[/* normalMatrixCacheMap */14],
      /* disposedIndexArray */transformRecord[/* disposedIndexArray */15]
    ]];
  return newrecord;
}

function _setDefaultChildren(indexArr, childMap) {
  return ArrayService$WonderCommonlib.reduceOneParam((function (childMap, index) {
                return SparseMapService$WonderCommonlib.set(index, ArrayService$WonderCommonlib.createEmpty(/* () */0), childMap);
              }), childMap, indexArr);
}

function _initTransformDataWhenCreate(indexArr, transformRecord) {
  var childMap = transformRecord[/* childMap */10];
  return /* record */[
          /* index */transformRecord[/* index */0],
          /* buffer */transformRecord[/* buffer */1],
          /* localToWorldMatrices */transformRecord[/* localToWorldMatrices */2],
          /* localPositions */transformRecord[/* localPositions */3],
          /* copiedBuffer */transformRecord[/* copiedBuffer */4],
          /* copiedLocalToWorldMatrices */transformRecord[/* copiedLocalToWorldMatrices */5],
          /* copiedLocalPositions */transformRecord[/* copiedLocalPositions */6],
          /* defaultLocalToWorldMatrix */transformRecord[/* defaultLocalToWorldMatrix */7],
          /* defaultLocalPosition */transformRecord[/* defaultLocalPosition */8],
          /* parentMap */transformRecord[/* parentMap */9],
          /* childMap */_setDefaultChildren(indexArr, childMap),
          /* gameObjectMap */transformRecord[/* gameObjectMap */11],
          /* dirtyMap */transformRecord[/* dirtyMap */12],
          /* localToWorldMatrixCacheMap */transformRecord[/* localToWorldMatrixCacheMap */13],
          /* normalMatrixCacheMap */transformRecord[/* normalMatrixCacheMap */14],
          /* disposedIndexArray */transformRecord[/* disposedIndexArray */15]
        ];
}

function _batchCreateTransform(param, state) {
  var transformRecord = RecordTransformMainService$Wonderjs.getRecord(state);
  var index = transformRecord[/* index */0];
  var newIndex = index + param[/* transforms */12].length | 0;
  var indexArr = _checkNotExceedMaxCountByIndex(BufferSettingService$Wonderjs.getTransformCount(state[/* settingRecord */0]), ArrayService$Wonderjs.range(index, newIndex - 1 | 0));
  transformRecord[/* index */0] = newIndex;
  var transformRecord$1 = _initTransformDataWhenCreate(indexArr, transformRecord);
  state[/* transformRecord */11] = /* Some */[ArrayService$WonderCommonlib.reduceOneParam((function (transformRecord, index) {
            return DirtyTransformService$Wonderjs.mark(index, true, transformRecord);
          }), transformRecord$1, indexArr)];
  return /* tuple */[
          state,
          indexArr
        ];
}

function _batchCreateGameObject(param, state) {
  var gameObjectRecord = state[/* gameObjectRecord */10];
  var count = param[/* gameObjects */3][/* count */0];
  var uid = gameObjectRecord[/* uid */0];
  var aliveUidArray = gameObjectRecord[/* aliveUidArray */20];
  var uidArr = ArrayService$Wonderjs.range(uid, (uid + count | 0) - 1 | 0);
  var newrecord = Caml_array.caml_array_dup(state);
  var newrecord$1 = Caml_array.caml_array_dup(gameObjectRecord);
  newrecord$1[/* uid */0] = uid + count | 0;
  newrecord$1[/* aliveUidArray */20] = aliveUidArray.concat(uidArr);
  newrecord[/* gameObjectRecord */10] = newrecord$1;
  return /* tuple */[
          newrecord,
          uidArr
        ];
}

function _buildSceneGameObject(param, gameObjectArr, state) {
  var scene = param[/* scene */1];
  var gameObjectRecord = state[/* gameObjectRecord */10];
  var gameObjects = scene[/* gameObjects */0];
  var match = gameObjects.length;
  if (match !== 1) {
    var match$1 = CreateGameObjectMainService$Wonderjs.create(state);
    var gameObject = match$1[1];
    var state$1 = match$1[0];
    var transformRecord = RecordTransformMainService$Wonderjs.getRecord(state$1);
    var parentMap = transformRecord[/* parentMap */9];
    var childMap = transformRecord[/* childMap */10];
    var match$2 = _addChildrenToParent(GetComponentGameObjectService$Wonderjs.unsafeGetTransformComponent(gameObject, gameObjectRecord), scene[/* gameObjects */0].map((function (gameObjectIndex) {
                return GetComponentGameObjectService$Wonderjs.unsafeGetTransformComponent(gameObjectArr[gameObjectIndex], gameObjectRecord);
              })), /* tuple */[
          parentMap,
          childMap
        ]);
    var newrecord = Caml_array.caml_array_dup(state$1);
    return /* tuple */[
            (newrecord[/* transformRecord */11] = /* Some */[/* record */[
                  /* index */transformRecord[/* index */0],
                  /* buffer */transformRecord[/* buffer */1],
                  /* localToWorldMatrices */transformRecord[/* localToWorldMatrices */2],
                  /* localPositions */transformRecord[/* localPositions */3],
                  /* copiedBuffer */transformRecord[/* copiedBuffer */4],
                  /* copiedLocalToWorldMatrices */transformRecord[/* copiedLocalToWorldMatrices */5],
                  /* copiedLocalPositions */transformRecord[/* copiedLocalPositions */6],
                  /* defaultLocalToWorldMatrix */transformRecord[/* defaultLocalToWorldMatrix */7],
                  /* defaultLocalPosition */transformRecord[/* defaultLocalPosition */8],
                  /* parentMap */match$2[0],
                  /* childMap */match$2[1],
                  /* gameObjectMap */transformRecord[/* gameObjectMap */11],
                  /* dirtyMap */transformRecord[/* dirtyMap */12],
                  /* localToWorldMatrixCacheMap */transformRecord[/* localToWorldMatrixCacheMap */13],
                  /* normalMatrixCacheMap */transformRecord[/* normalMatrixCacheMap */14],
                  /* disposedIndexArray */transformRecord[/* disposedIndexArray */15]
                ]], newrecord),
            gameObject
          ];
  } else {
    return /* tuple */[
            state,
            gameObjectArr[Caml_array.caml_array_get(gameObjects, 0)]
          ];
  }
}

function _getBatchArrByIndices(sourceArr, indices) {
  return indices.map((function (index) {
                return sourceArr[index];
              }));
}

function _getBatchComponentGameObjectData(param, indices) {
  var transformArr = param[1];
  var gameObjectArr = param[0];
  var parentTransforms = _getBatchArrByIndices(transformArr, indices[/* gameObjectIndices */0][/* childrenTransformIndexData */0][/* parentTransformIndices */0]);
  var childrenTransforms = indices[/* gameObjectIndices */0][/* childrenTransformIndexData */0][/* childrenTransformIndices */1].map((function (childrenIndices) {
          return childrenIndices.map((function (index) {
                        return transformArr[index];
                      }));
        }));
  var transformGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* transformGameObjectIndexData */1][/* gameObjectIndices */0]);
  var gameObjectTransforms = _getBatchArrByIndices(transformArr, indices[/* gameObjectIndices */0][/* transformGameObjectIndexData */1][/* componentIndices */1]);
  var customGeometryGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* customGeometryGameObjectIndexData */5][/* gameObjectIndices */0]);
  var gameObjectCustomGeometrys = _getBatchArrByIndices(param[2], indices[/* gameObjectIndices */0][/* customGeometryGameObjectIndexData */5][/* componentIndices */1]);
  return /* tuple */[
          parentTransforms,
          childrenTransforms,
          transformGameObjects,
          gameObjectTransforms,
          customGeometryGameObjects,
          gameObjectCustomGeometrys
        ];
}

function assemble(param, state) {
  var wdRecord = param[0];
  var match = _batchCreateGameObject(wdRecord, state);
  var gameObjectArr = match[1];
  var match$1 = _batchCreateTransform(wdRecord, match[0]);
  var match$2 = _batchCreateCustomGeometry(wdRecord, match$1[0]);
  var customGeometryArr = match$2[1];
  var match$3 = _getBatchComponentGameObjectData(/* tuple */[
        gameObjectArr,
        match$1[1],
        customGeometryArr
      ], wdRecord[/* indices */2]);
  var gameObjectTransforms = match$3[3];
  var state$1 = BatchAddGameObjectComponentMainService$Wonderjs.batchAddCustomGeometryComponentForCreate(match$3[4], match$3[5], BatchAddGameObjectComponentMainService$Wonderjs.batchAddTransformComponentForCreate(match$3[2], gameObjectTransforms, _batchSetCustomGeometryData(wdRecord, customGeometryArr, param[2], _batchSetTransformParent(match$3[0], match$3[1], _batchSetTransformData(wdRecord, gameObjectTransforms, match$2[0])))));
  return _buildSceneGameObject(wdRecord, gameObjectArr, state$1);
}

export {
  _getAccessorTypeSize ,
  _getBufferAttributeData ,
  _getBufferIndexData ,
  _batchSetCustomGeometryData ,
  _checkNotExceedMaxCountByIndex ,
  _batchCreateCustomGeometry ,
  _addChildrenToParent ,
  _batchSetTransformParent ,
  _batchSetTransformData ,
  _setDefaultChildren ,
  _initTransformDataWhenCreate ,
  _batchCreateTransform ,
  _batchCreateGameObject ,
  _buildSceneGameObject ,
  _getBatchArrByIndices ,
  _getBatchComponentGameObjectData ,
  assemble ,
  
}
/* Log-WonderLog Not a pure module */
