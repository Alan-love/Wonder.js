// Generated by BUCKLESCRIPT VERSION 3.1.4, PLEASE EDIT WITH CARE

import * as Caml_array from "../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Log$WonderLog from "../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as ArrayService$Wonderjs from "../../service/atom/ArrayService.js";
import * as GameObjectAPI$Wonderjs from "../../api/GameObjectAPI.js";
import * as OptionService$Wonderjs from "../../service/atom/OptionService.js";
import * as ArrayService$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArrayService.js";
import * as SparseMapService$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapService.js";
import * as HierachyTransformService$Wonderjs from "../../service/record/main/transform/HierachyTransformService.js";
import * as GameObjectTransformService$Wonderjs from "../../service/record/main/transform/GameObjectTransformService.js";
import * as RecordTransformMainService$Wonderjs from "../../service/state/main/transform/RecordTransformMainService.js";
import * as ModelMatrixTransformService$Wonderjs from "../../service/record/main/transform/ModelMatrixTransformService.js";
import * as NameLightMaterialMainService$Wonderjs from "../../service/state/main/material/light/NameLightMaterialMainService.js";
import * as GetComponentGameObjectService$Wonderjs from "../../service/record/main/gameObject/GetComponentGameObjectService.js";
import * as CurrentComponentDataMapService$Wonderjs from "../../service/record/all/gameObject/CurrentComponentDataMapService.js";
import * as OperateLightMaterialMainService$Wonderjs from "../../service/state/main/material/light/OperateLightMaterialMainService.js";
import * as GetBoxGeometryIndicesMainService$Wonderjs from "../../service/state/main/geometry/box/GetBoxGeometryIndicesMainService.js";
import * as GetBoxGeometryNormalsMainService$Wonderjs from "../../service/state/main/geometry/box/GetBoxGeometryNormalsMainService.js";
import * as IndicesCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/IndicesCustomGeometryMainService.js";
import * as NormalsCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/NormalsCustomGeometryMainService.js";
import * as GetBoxGeometryVerticesMainService$Wonderjs from "../../service/state/main/geometry/box/GetBoxGeometryVerticesMainService.js";
import * as VerticesCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/VerticesCustomGeometryMainService.js";
import * as GetBoxGeometryTexCoordsMainService$Wonderjs from "../../service/state/main/geometry/box/GetBoxGeometryTexCoordsMainService.js";
import * as TexCoordsCustomGeometryMainService$Wonderjs from "../../service/state/main/geometry/custom/TexCoordsCustomGeometryMainService.js";

var _getChildren = HierachyTransformService$Wonderjs.unsafeGetChildren;

function _hasMap(gameObject, state) {
  var gameObjectRecord = state[/* gameObjectRecord */10];
  var match = GetComponentGameObjectService$Wonderjs.getLightMaterialComponent(gameObject, gameObjectRecord);
  if (match) {
    var lightMaterial = match[0];
    if (OperateLightMaterialMainService$Wonderjs.hasDiffuseMap(lightMaterial, state)) {
      return true;
    } else {
      return OperateLightMaterialMainService$Wonderjs.hasSpecularMap(lightMaterial, state);
    }
  } else {
    return false;
  }
}

function _setChildren(gameObjectChildrenMap, gameObjectNodeIndexMap, nodeDataArr) {
  return ArrayService$WonderCommonlib.reduceOneParam((function (newNodeDataArr, nodeData) {
                var match = SparseMapService$WonderCommonlib.get(nodeData[/* gameObject */0], gameObjectChildrenMap);
                return ArrayService$Wonderjs.push(/* record */[
                            /* gameObject */nodeData[/* gameObject */0],
                            /* children */match ? /* Some */[match[0].map((function (childGameObject) {
                                        return SparseMapService$WonderCommonlib.unsafeGet(childGameObject, gameObjectNodeIndexMap);
                                      }))] : /* None */0,
                            /* translation */nodeData[/* translation */2],
                            /* rotation */nodeData[/* rotation */3],
                            /* scale */nodeData[/* scale */4],
                            /* mesh */nodeData[/* mesh */5],
                            /* camera */nodeData[/* camera */6],
                            /* extras */nodeData[/* extras */7],
                            /* extensions */nodeData[/* extensions */8]
                          ], newNodeDataArr);
              }), /* array */[], nodeDataArr);
}

function _getMeshData(param, param$1, state) {
  var customGeometryDataMap = param$1[1];
  var boxGeometryDataMap = param$1[0];
  var meshIndex = param[1];
  var gameObject = param[0];
  var gameObjectRecord = state[/* gameObjectRecord */10];
  var match = GetComponentGameObjectService$Wonderjs.getGeometryComponentData(gameObject, gameObjectRecord);
  if (match) {
    var match$1 = match[0];
    var type_ = match$1[1];
    var geometry = match$1[0];
    if (type_ === CurrentComponentDataMapService$Wonderjs.getBoxGeometryType(/* () */0)) {
      var match$2 = SparseMapService$WonderCommonlib.get(geometry, boxGeometryDataMap);
      if (match$2) {
        var match$3 = match$2[0];
        return /* tuple */[
                /* Some */[match$3[0]],
                match$3[1],
                meshIndex,
                /* tuple */[
                  boxGeometryDataMap,
                  customGeometryDataMap
                ]
              ];
      } else {
        var match$4 = _hasMap(gameObject, state);
        var pointData = /* Some */[/* tuple */[
            GetBoxGeometryVerticesMainService$Wonderjs.getVertices(state),
            GetBoxGeometryNormalsMainService$Wonderjs.getNormals(state),
            match$4 ? /* Some */[GetBoxGeometryTexCoordsMainService$Wonderjs.getTexCoords(state)] : /* None */0,
            GetBoxGeometryIndicesMainService$Wonderjs.getIndices(state)
          ]];
        return /* tuple */[
                /* Some */[meshIndex],
                pointData,
                meshIndex + 1 | 0,
                /* tuple */[
                  SparseMapService$WonderCommonlib.set(geometry, /* tuple */[
                        meshIndex,
                        pointData
                      ], boxGeometryDataMap),
                  customGeometryDataMap
                ]
              ];
      }
    } else if (type_ === CurrentComponentDataMapService$Wonderjs.getCustomGeometryType(/* () */0)) {
      var match$5 = SparseMapService$WonderCommonlib.get(geometry, customGeometryDataMap);
      if (match$5) {
        var match$6 = match$5[0];
        return /* tuple */[
                /* Some */[match$6[0]],
                match$6[1],
                meshIndex,
                /* tuple */[
                  boxGeometryDataMap,
                  customGeometryDataMap
                ]
              ];
      } else {
        var match$7 = _hasMap(gameObject, state);
        var pointData$1 = /* Some */[/* tuple */[
            VerticesCustomGeometryMainService$Wonderjs.getVertices(geometry, state),
            NormalsCustomGeometryMainService$Wonderjs.getNormals(geometry, state),
            match$7 ? /* Some */[TexCoordsCustomGeometryMainService$Wonderjs.getTexCoords(geometry, state)] : /* None */0,
            IndicesCustomGeometryMainService$Wonderjs.getIndices(geometry, state)
          ]];
        return /* tuple */[
                /* Some */[meshIndex],
                pointData$1,
                meshIndex + 1 | 0,
                /* tuple */[
                  boxGeometryDataMap,
                  SparseMapService$WonderCommonlib.set(geometry, /* tuple */[
                        meshIndex,
                        pointData$1
                      ], customGeometryDataMap)
                ]
              ];
      }
    } else {
      return Log$WonderLog.fatal(Log$WonderLog.buildFatalMessage("unknown type_", "", "", "", "type_: " + (String(type_) + "")));
    }
  } else {
    return /* tuple */[
            /* None */0,
            /* None */0,
            meshIndex,
            /* tuple */[
              boxGeometryDataMap,
              customGeometryDataMap
            ]
          ];
  }
}

function _getLightMaterialData(param, lightMaterialDataMap, state) {
  var materialIndex = param[1];
  var gameObjectRecord = state[/* gameObjectRecord */10];
  var match = GetComponentGameObjectService$Wonderjs.getLightMaterialComponent(param[0], gameObjectRecord);
  if (match) {
    var lightMaterial = match[0];
    var match$1 = SparseMapService$WonderCommonlib.get(lightMaterial, lightMaterialDataMap);
    if (match$1) {
      var match$2 = match$1[0];
      return /* tuple */[
              /* Some */[match$2[0]],
              match$2[1],
              materialIndex,
              lightMaterialDataMap
            ];
    } else {
      var materialData = /* Some */[/* tuple */[
          lightMaterial,
          NameLightMaterialMainService$Wonderjs.getName(lightMaterial, state)
        ]];
      return /* tuple */[
              /* Some */[materialIndex],
              materialData,
              materialIndex + 1 | 0,
              SparseMapService$WonderCommonlib.set(lightMaterial, /* tuple */[
                    materialIndex,
                    materialData
                  ], lightMaterialDataMap)
            ];
    }
  } else {
    return /* tuple */[
            /* None */0,
            /* None */0,
            materialIndex,
            lightMaterialDataMap
          ];
  }
}

function _getCameraData(param, state) {
  var cameraIndex = param[1];
  var gameObjectRecord = state[/* gameObjectRecord */10];
  var match = GetComponentGameObjectService$Wonderjs.getPerspectiveCameraProjectionComponent(param[0], gameObjectRecord);
  if (match) {
    var cameraData = /* Some */[match[0]];
    return /* tuple */[
            /* Some */[cameraIndex],
            cameraData,
            cameraIndex + 1 | 0
          ];
  } else {
    return /* tuple */[
            /* None */0,
            /* None */0,
            cameraIndex
          ];
  }
}

function _getLightData(param, state) {
  var lightIndex = param[1];
  var gameObject = param[0];
  var gameObjectRecord = state[/* gameObjectRecord */10];
  var match = GetComponentGameObjectService$Wonderjs.getDirectionLightComponent(gameObject, gameObjectRecord);
  if (match) {
    var lightData = /* Some */[/* tuple */[
        "directional",
        match[0]
      ]];
    return /* tuple */[
            /* Some */[lightIndex],
            lightData,
            lightIndex + 1 | 0
          ];
  } else {
    var match$1 = GetComponentGameObjectService$Wonderjs.getPointLightComponent(gameObject, gameObjectRecord);
    if (match$1) {
      var lightData$1 = /* Some */[/* tuple */[
          "point",
          match$1[0]
        ]];
      return /* tuple */[
              /* Some */[lightIndex],
              lightData$1,
              lightIndex + 1 | 0
            ];
    } else {
      return /* tuple */[
              /* None */0,
              /* None */0,
              lightIndex
            ];
    }
  }
}

function _getNodeData(state, param, param$1, param$2, param$3) {
  var match = param$1[0];
  return ArrayService$WonderCommonlib.reduceOneParam((function (param, transform) {
                var state = param[0];
                var nodeDataArr = param[4];
                var match = param[3];
                var lightDataMap = match[3];
                var cameraDataMap = match[2];
                var materialDataMap = match[1];
                var meshPointDataMap = match[0];
                var match$1 = param[2];
                var gameObjectChildrenMap = match$1[2];
                var match$2 = match$1[0];
                var match$3 = param[1];
                var nodeIndex = match$3[0];
                var transformRecord = RecordTransformMainService$Wonderjs.getRecord(state);
                var localPositions = transformRecord[/* localPositions */3];
                var localRotations = transformRecord[/* localRotations */4];
                var localScales = transformRecord[/* localScales */5];
                var defaultLocalScale = transformRecord[/* defaultLocalScale */14];
                var defaultLocalRotation = transformRecord[/* defaultLocalRotation */13];
                var defaultLocalPosition = transformRecord[/* defaultLocalPosition */12];
                var gameObject = GameObjectTransformService$Wonderjs.unsafeGetGameObject(transform, transformRecord);
                var childrenTransformArr = HierachyTransformService$Wonderjs.unsafeGetChildren(transform, transformRecord);
                var childrenGameObjectArr = childrenTransformArr.map((function (transform) {
                        return GameObjectTransformService$Wonderjs.unsafeGetGameObject(transform, transformRecord);
                      }));
                var match$4 = _getMeshData(/* tuple */[
                      gameObject,
                      match$3[1]
                    ], /* tuple */[
                      match$2[0],
                      match$2[1]
                    ], state);
                var match$5 = match$4[3];
                var meshIndex = match$4[0];
                var meshPointDataMap$1 = meshIndex ? SparseMapService$WonderCommonlib.set(meshIndex[0], OptionService$Wonderjs.unsafeGet(match$4[1]), meshPointDataMap) : meshPointDataMap;
                var match$6 = _getLightMaterialData(/* tuple */[
                      gameObject,
                      match$3[2]
                    ], match$1[1], state);
                var materialIndex = match$6[0];
                var materialDataMap$1 = materialIndex ? SparseMapService$WonderCommonlib.set(materialIndex[0], OptionService$Wonderjs.unsafeGet(match$6[1]), materialDataMap) : materialDataMap;
                var match$7 = _getCameraData(/* tuple */[
                      gameObject,
                      match$3[3]
                    ], state);
                var cameraIndex = match$7[0];
                var cameraDataMap$1 = cameraIndex ? SparseMapService$WonderCommonlib.set(cameraIndex[0], OptionService$Wonderjs.unsafeGet(match$7[1]), cameraDataMap) : cameraDataMap;
                var match$8 = _getLightData(/* tuple */[
                      gameObject,
                      match$3[4]
                    ], state);
                var lightIndex = match$8[0];
                var lightDataMap$1 = lightIndex ? SparseMapService$WonderCommonlib.set(lightIndex[0], OptionService$Wonderjs.unsafeGet(match$8[1]), lightDataMap) : lightDataMap;
                var match$9 = childrenGameObjectArr.length;
                var gameObjectChildrenMap$1 = match$9 !== 0 ? SparseMapService$WonderCommonlib.set(gameObject, childrenGameObjectArr, gameObjectChildrenMap) : gameObjectChildrenMap;
                var gameObjectNodeIndexMap = SparseMapService$WonderCommonlib.set(gameObject, nodeIndex, match$1[3]);
                var newNodeIndex = nodeIndex + 1 | 0;
                var localPosition = ModelMatrixTransformService$Wonderjs.getLocalPositionTuple(transform, localPositions);
                var localRotation = ModelMatrixTransformService$Wonderjs.getLocalRotationTuple(transform, localRotations);
                var localScale = ModelMatrixTransformService$Wonderjs.getLocalScaleTuple(transform, localScales);
                ArrayService$Wonderjs.push(/* record */[
                      /* gameObject */gameObject,
                      /* children : None */0,
                      /* translation */localPosition[0] === Caml_array.caml_array_get(defaultLocalPosition, 0) && localPosition[1] === Caml_array.caml_array_get(defaultLocalPosition, 1) && localPosition[2] === Caml_array.caml_array_get(defaultLocalPosition, 2) ? /* None */0 : /* Some */[localPosition],
                      /* rotation */localRotation[0] === Caml_array.caml_array_get(defaultLocalRotation, 0) && localRotation[1] === Caml_array.caml_array_get(defaultLocalRotation, 1) && localRotation[2] === Caml_array.caml_array_get(defaultLocalRotation, 2) && localRotation[3] === Caml_array.caml_array_get(defaultLocalRotation, 3) ? /* None */0 : /* Some */[localRotation],
                      /* scale */localScale[0] === Caml_array.caml_array_get(defaultLocalScale, 0) && localScale[1] === Caml_array.caml_array_get(defaultLocalScale, 1) && localScale[2] === Caml_array.caml_array_get(defaultLocalScale, 2) ? /* None */0 : /* Some */[localScale],
                      /* mesh */meshIndex,
                      /* camera */cameraIndex,
                      /* extras */materialIndex ? /* Some */[/* record */[/* material : Some */[materialIndex[0]]]] : /* None */0,
                      /* extensions */lightIndex ? /* Some */[/* record */[/* khr_lights : Some */[/* record */[/* light */lightIndex[0]]]]] : /* None */0
                    ], nodeDataArr);
                return _getNodeData(state, /* tuple */[
                            newNodeIndex,
                            match$4[2],
                            match$6[2],
                            match$7[2],
                            match$8[2]
                          ], /* tuple */[
                            /* tuple */[
                              match$5[0],
                              match$5[1]
                            ],
                            match$6[3],
                            gameObjectChildrenMap$1,
                            gameObjectNodeIndexMap
                          ], /* tuple */[
                            meshPointDataMap$1,
                            materialDataMap$1,
                            cameraDataMap$1,
                            lightDataMap$1
                          ], /* tuple */[
                            childrenTransformArr,
                            nodeDataArr
                          ]);
              }), /* tuple */[
              state,
              /* tuple */[
                param[0],
                param[1],
                param[2],
                param[3],
                param[4]
              ],
              /* tuple */[
                /* tuple */[
                  match[0],
                  match[1]
                ],
                param$1[1],
                param$1[2],
                param$1[3]
              ],
              /* tuple */[
                param$2[0],
                param$2[1],
                param$2[2],
                param$2[3]
              ],
              param$3[1]
            ], param$3[0]);
}

function getAllNodeData(sceneGameObject, state) {
  var match = _getNodeData(state, /* tuple */[
        0,
        0,
        0,
        0,
        0
      ], /* tuple */[
        /* tuple */[
          SparseMapService$WonderCommonlib.createEmpty(/* () */0),
          SparseMapService$WonderCommonlib.createEmpty(/* () */0)
        ],
        SparseMapService$WonderCommonlib.createEmpty(/* () */0),
        SparseMapService$WonderCommonlib.createEmpty(/* () */0),
        SparseMapService$WonderCommonlib.createEmpty(/* () */0)
      ], /* tuple */[
        SparseMapService$WonderCommonlib.createEmpty(/* () */0),
        SparseMapService$WonderCommonlib.createEmpty(/* () */0),
        SparseMapService$WonderCommonlib.createEmpty(/* () */0),
        SparseMapService$WonderCommonlib.createEmpty(/* () */0)
      ], /* tuple */[
        /* array */[GameObjectAPI$Wonderjs.unsafeGetGameObjectTransformComponent(sceneGameObject, state)],
        /* array */[]
      ]);
  var nodeDataArr = match[4];
  var match$1 = match[3];
  var lightDataMap = match$1[3];
  var cameraDataMap = match$1[2];
  var materialDataMap = match$1[1];
  var meshPointDataMap = match$1[0];
  var match$2 = match[2];
  var gameObjectNodeIndexMap = match$2[3];
  var gameObjectChildrenMap = match$2[2];
  var state$1 = match[0];
  var nodeDataArr$1 = _setChildren(gameObjectChildrenMap, gameObjectNodeIndexMap, nodeDataArr);
  return /* tuple */[
          state$1,
          /* tuple */[
            meshPointDataMap,
            materialDataMap,
            cameraDataMap,
            lightDataMap
          ],
          nodeDataArr$1
        ];
}

export {
  _getChildren ,
  _hasMap ,
  _setChildren ,
  _getMeshData ,
  _getLightMaterialData ,
  _getCameraData ,
  _getLightData ,
  _getNodeData ,
  getAllNodeData ,
  
}
/* Log-WonderLog Not a pure module */
