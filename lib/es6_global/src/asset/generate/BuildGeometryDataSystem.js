// Generated by BUCKLESCRIPT VERSION 3.1.4, PLEASE EDIT WITH CARE

import * as Caml_int32 from "../../../../../node_modules/bs-platform/lib/es6/caml_int32.js";
import * as Log$WonderLog from "../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog from "../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as BinaryUtils$Wonderjs from "../utils/BinaryUtils.js";
import * as ArrayService$Wonderjs from "../../service/atom/ArrayService.js";
import * as OptionService$Wonderjs from "../../service/atom/OptionService.js";
import * as StateDataMain$Wonderjs from "../../service/state/main/data/StateDataMain.js";
import * as GenerateCommon$Wonderjs from "./GenerateCommon.js";
import * as SparseMapService$Wonderjs from "../../service/atom/SparseMapService.js";
import * as IsDebugMainService$Wonderjs from "../../service/state/main/state/IsDebugMainService.js";

function _addBufferViewData(param, param$1, totalByteLength) {
  var accessorDataArr = param$1[2];
  var bufferViewDataArr = param$1[1];
  var bufferViewOffset = param$1[0];
  var pointType = param[3];
  var pointsLength = param[0];
  if (pointsLength !== 0) {
    var bufferViewByteLength = Caml_int32.imul(pointsLength, param[2]);
    var bufferViewAlignedByteLength = BinaryUtils$Wonderjs.alignedLength(bufferViewByteLength);
    return /* tuple */[
            /* Some */[accessorDataArr.length],
            ArrayService$Wonderjs.push(/* record */[
                  /* bufferView */bufferViewDataArr.length,
                  /* componentType */pointType >= 3 ? 5123 : 5126,
                  /* count */param[1],
                  /* type_ */pointType !== 2 ? (
                      pointType >= 3 ? "SCALAR" : "VEC3"
                    ) : "VEC2"
                ], accessorDataArr),
            ArrayService$Wonderjs.push(/* record */[
                  /* buffer */0,
                  /* byteOffset */bufferViewOffset,
                  /* byteLength */bufferViewByteLength
                ], bufferViewDataArr),
            bufferViewOffset + bufferViewAlignedByteLength | 0,
            totalByteLength + bufferViewAlignedByteLength | 0
          ];
  } else {
    return /* tuple */[
            /* None */0,
            accessorDataArr,
            bufferViewDataArr,
            bufferViewOffset,
            totalByteLength
          ];
  }
}

function _checkBufferViewOffsetAligned(bufferViewOffset) {
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("bufferViewOffset aligned with multiple of 4", "not"), (function () {
                        return Contract$WonderLog.Operators[/* = */0](bufferViewOffset % 4, 0);
                      }));
        }), IsDebugMainService$Wonderjs.getIsDebug(StateDataMain$Wonderjs.stateData));
  return bufferViewOffset;
}

function _addVertexData(param, vertexDataArr) {
  var bufferViewOffset = param[0];
  _checkBufferViewOffsetAligned(bufferViewOffset);
  return ArrayService$Wonderjs.push(/* tuple */[
              bufferViewOffset,
              param[1]
            ], vertexDataArr);
}

function _addIndexData(param, indexDataArr) {
  var bufferViewOffset = param[0];
  _checkBufferViewOffsetAligned(bufferViewOffset);
  return ArrayService$Wonderjs.push(/* tuple */[
              bufferViewOffset,
              param[1]
            ], indexDataArr);
}

function _addAllPointData(param, param$1, param$2, param$3, param$4) {
  var match = param$4[1];
  var texCoords = param$3[2];
  var match$1 = param$2[1];
  var bufferViewOffset = param$2[0];
  var indicesLength = param$1[3];
  var texCoordsLength = param$1[2];
  var normalsLength = param$1[1];
  var verticesLength = param$1[0];
  var verticesCount = Caml_int32.div(verticesLength, param[0]);
  var normalsCount = Caml_int32.div(normalsLength, param[1]);
  var texCoordsCount = Caml_int32.div(texCoordsLength, param[2]);
  var indicesCount = Caml_int32.div(indicesLength, param[3]);
  var vertexDataArr = _addVertexData(/* tuple */[
        bufferViewOffset,
        param$3[0]
      ], match[0]);
  var match$2 = _addBufferViewData(/* tuple */[
        verticesLength,
        verticesCount,
        Float32Array.BYTES_PER_ELEMENT,
        /* VERTEX */0
      ], /* tuple */[
        bufferViewOffset,
        match$1[0],
        match$1[1]
      ], param$4[0]);
  var bufferViewOffset$1 = match$2[3];
  var vertexDataArr$1 = _addVertexData(/* tuple */[
        bufferViewOffset$1,
        param$3[1]
      ], vertexDataArr);
  var match$3 = _addBufferViewData(/* tuple */[
        normalsLength,
        normalsCount,
        Float32Array.BYTES_PER_ELEMENT,
        /* NORMAL */1
      ], /* tuple */[
        bufferViewOffset$1,
        match$2[2],
        match$2[1]
      ], match$2[4]);
  var bufferViewOffset$2 = match$3[3];
  var vertexDataArr$2 = texCoords ? _addVertexData(/* tuple */[
          bufferViewOffset$2,
          texCoords[0]
        ], vertexDataArr$1) : vertexDataArr$1;
  var match$4 = _addBufferViewData(/* tuple */[
        texCoordsLength,
        texCoordsCount,
        Float32Array.BYTES_PER_ELEMENT,
        /* TEXCOORD */2
      ], /* tuple */[
        bufferViewOffset$2,
        match$3[2],
        match$3[1]
      ], match$3[4]);
  var bufferViewOffset$3 = match$4[3];
  var indexDataArr = _addIndexData(/* tuple */[
        bufferViewOffset$3,
        param$3[3]
      ], match[1]);
  var match$5 = _addBufferViewData(/* tuple */[
        indicesLength,
        indicesCount,
        Uint16Array.BYTES_PER_ELEMENT,
        /* INDEX */3
      ], /* tuple */[
        bufferViewOffset$3,
        match$4[2],
        match$4[1]
      ], match$4[4]);
  return /* tuple */[
          /* tuple */[
            match$2[0],
            match$3[0],
            match$4[0],
            match$5[0]
          ],
          match$5[1],
          match$5[2],
          match$5[3],
          /* tuple */[
            match$5[4],
            /* tuple */[
              vertexDataArr$2,
              indexDataArr
            ]
          ]
        ];
}

function _addMeshData(param, texCoords, meshDataArr) {
  return ArrayService$Wonderjs.push(/* record */[
              /* primitives : record */[
                /* attributes : record */[
                  /* position */OptionService$Wonderjs.unsafeGet(param[0]),
                  /* normal */param[1],
                  /* texCoord_0 */texCoords ? param[2] : /* None */0
                ],
                /* indices */OptionService$Wonderjs.unsafeGet(param[3]),
                /* material : None */0
              ],
              /* name : None */0
            ], meshDataArr);
}

function build(meshPointDataMap) {
  Contract$WonderLog.requireCheck((function () {
          return GenerateCommon$Wonderjs.checkShouldHasNoSlot(meshPointDataMap);
        }), IsDebugMainService$Wonderjs.getIsDebug(StateDataMain$Wonderjs.stateData));
  var match = SparseMapService$Wonderjs.reduceiValid((function (param, param$1, _) {
          var indices = param$1[3];
          var texCoords = param$1[2];
          var normals = param$1[1];
          var vertices = param$1[0];
          var match = param[2];
          var match$1 = param[1];
          var match$2 = param[0];
          var verticesLength = vertices.length;
          var normalsLength = normals.length;
          var texCoordsLength = texCoords ? texCoords[0].length : 0;
          var indicesLength = indices.length;
          var match$3 = _addAllPointData(/* tuple */[
                3,
                3,
                2,
                1
              ], /* tuple */[
                verticesLength,
                normalsLength,
                texCoordsLength,
                indicesLength
              ], /* tuple */[
                match$2[1],
                /* tuple */[
                  match$1[0],
                  match$1[1]
                ]
              ], /* tuple */[
                vertices,
                normals,
                texCoords,
                indices
              ], /* tuple */[
                match$2[0],
                /* tuple */[
                  match[0],
                  match[1]
                ]
              ]);
          var match$4 = match$3[4];
          var match$5 = match$4[1];
          var match$6 = match$3[0];
          return /* tuple */[
                  /* tuple */[
                    match$4[0],
                    match$3[3]
                  ],
                  /* tuple */[
                    match$3[2],
                    match$3[1],
                    _addMeshData(/* tuple */[
                          match$6[0],
                          match$6[1],
                          match$6[2],
                          match$6[3]
                        ], texCoords, match$1[2])
                  ],
                  /* tuple */[
                    match$5[0],
                    match$5[1]
                  ]
                ];
        }), /* tuple */[
        /* tuple */[
          0,
          0
        ],
        /* tuple */[
          /* array */[],
          /* array */[],
          /* array */[]
        ],
        /* tuple */[
          /* array */[],
          /* array */[]
        ]
      ], meshPointDataMap);
  var match$1 = match[2];
  var match$2 = match[1];
  return /* tuple */[
          match[0][0],
          /* tuple */[
            match$2[0],
            match$2[1],
            match$2[2]
          ],
          /* tuple */[
            match$1[0],
            match$1[1]
          ]
        ];
}

export {
  _addBufferViewData ,
  _checkBufferViewOffsetAligned ,
  _addVertexData ,
  _addIndexData ,
  _addAllPointData ,
  _addMeshData ,
  build ,
  
}
/* Log-WonderLog Not a pure module */
