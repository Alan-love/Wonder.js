// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Caml_array                          from "../../../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Caml_int32                          from "../../../../../../../node_modules/bs-platform/lib/es6/caml_int32.js";
import * as Vector3System$Wonderjs              from "../../../../structure/Vector3System.js";
import * as ArraySystem$WonderCommonlib         from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArraySystem.js";
import * as GeometryCreateCommon$Wonderjs       from "./GeometryCreateCommon.js";
import * as HashMapSystem$WonderCommonlib       from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/HashMapSystem.js";
import * as ExceptionHandleSystem$Wonderjs      from "../../../../exception/ExceptionHandleSystem.js";
import * as SparseMapSystem$WonderCommonlib     from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapSystem.js";
import * as GeometryConfigDataCommon$Wonderjs   from "./GeometryConfigDataCommon.js";
import * as GeometryGetStateDataCommon$Wonderjs from "./GeometryGetStateDataCommon.js";

function _getConfig(configDataMap) {
  return /* tuple */[
          HashMapSystem$WonderCommonlib.unsafeGet("width", configDataMap),
          HashMapSystem$WonderCommonlib.unsafeGet("height", configDataMap),
          HashMapSystem$WonderCommonlib.unsafeGet("depth", configDataMap),
          HashMapSystem$WonderCommonlib.unsafeGet("widthSegment", configDataMap) | 0,
          HashMapSystem$WonderCommonlib.unsafeGet("heightSegment", configDataMap) | 0,
          HashMapSystem$WonderCommonlib.unsafeGet("depthSegment", configDataMap) | 0
        ];
}

function _buildFaceData(width, height, depth) {
  return /* tuple */[
          /* array */[
            /* int array */[
              0,
              1,
              3
            ],
            /* int array */[
              4,
              5,
              7
            ],
            /* int array */[
              3,
              2,
              6
            ],
            /* int array */[
              1,
              0,
              4
            ],
            /* int array */[
              1,
              4,
              2
            ],
            /* int array */[
              5,
              0,
              6
            ]
          ],
          /* array */[
            /* tuple */[
              -width,
              -height,
              depth
            ],
            /* tuple */[
              width,
              -height,
              depth
            ],
            /* tuple */[
              width,
              height,
              depth
            ],
            /* tuple */[
              -width,
              height,
              depth
            ],
            /* tuple */[
              width,
              -height,
              -depth
            ],
            /* tuple */[
              -width,
              -height,
              -depth
            ],
            /* tuple */[
              -width,
              height,
              -depth
            ],
            /* tuple */[
              width,
              height,
              -depth
            ]
          ]
        ];
}

function _getLerpData(param, param$1, param$2) {
  var side = param$1[0];
  var corners = param[1];
  var faceAxes = param[0];
  return Vector3System$Wonderjs.lerp(Caml_array.caml_array_get(corners, Caml_array.caml_array_get(Caml_array.caml_array_get(faceAxes, side), param$2[0])), Caml_array.caml_array_get(corners, Caml_array.caml_array_get(Caml_array.caml_array_get(faceAxes, side), param$2[1])), param$2[2] / param$1[1]);
}

function _generateVertex(param, param$1, param$2, vertices) {
  var corners = param$1[1];
  var faceAxes = param$1[0];
  var side = param[0];
  var match = Vector3System$Wonderjs.add(/* Float */0, _getLerpData(/* tuple */[
            faceAxes,
            corners
          ], /* tuple */[
            side,
            param[1]
          ], /* tuple */[
            0,
            1,
            param$2[0]
          ]), Vector3System$Wonderjs.sub(/* Float */0, _getLerpData(/* tuple */[
                faceAxes,
                corners
              ], /* tuple */[
                side,
                param[2]
              ], /* tuple */[
                0,
                2,
                param$2[1]
              ]), Caml_array.caml_array_get(corners, Caml_array.caml_array_get(Caml_array.caml_array_get(faceAxes, side), 0))));
  vertices.push(match[0], match[1], match[2]);
  return /* () */0;
}

function _generateIndex(param, param$1, indices) {
  var vSegmentIndex = param$1[1];
  var uSegmentIndex = param$1[0];
  var offset = param[2];
  var uSegment = param[0];
  if (uSegmentIndex < uSegment && vSegmentIndex < param[1]) {
    indices.push((offset + vSegmentIndex | 0) + Caml_int32.imul(uSegmentIndex, uSegment + 1 | 0) | 0, (offset + vSegmentIndex | 0) + Caml_int32.imul(uSegmentIndex + 1 | 0, uSegment + 1 | 0) | 0, ((offset + vSegmentIndex | 0) + Caml_int32.imul(uSegmentIndex, uSegment + 1 | 0) | 0) + 1 | 0, (offset + vSegmentIndex | 0) + Caml_int32.imul(uSegmentIndex + 1 | 0, uSegment + 1 | 0) | 0, ((offset + vSegmentIndex | 0) + Caml_int32.imul(uSegmentIndex + 1 | 0, uSegment + 1 | 0) | 0) + 1 | 0, ((offset + vSegmentIndex | 0) + Caml_int32.imul(uSegmentIndex, uSegment + 1 | 0) | 0) + 1 | 0);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function _generateFace(directionDataTuple, faceDataTuple, param) {
  var vSegment = directionDataTuple[2];
  var uSegment = directionDataTuple[1];
  var indices = param[1];
  var vertices = param[0];
  var offset = vertices.length / 3 | 0;
  for(var i = 0; i <= uSegment; ++i){
    for(var j = 0; j <= vSegment; ++j){
      var segmentIndexTuple = /* tuple */[
        i,
        j
      ];
      _generateVertex(directionDataTuple, faceDataTuple, segmentIndexTuple, vertices);
      _generateIndex(/* tuple */[
            uSegment,
            vSegment,
            offset
          ], segmentIndexTuple, indices);
    }
  }
  return /* tuple */[
          vertices,
          indices
        ];
}

function _buildAllFaceDirectionDataTupleArr(widthSegment, heightSegment, depthSegment) {
  return /* array */[
          /* tuple */[
            0,
            widthSegment,
            heightSegment
          ],
          /* tuple */[
            1,
            widthSegment,
            heightSegment
          ],
          /* tuple */[
            2,
            widthSegment,
            depthSegment
          ],
          /* tuple */[
            3,
            widthSegment,
            depthSegment
          ],
          /* tuple */[
            4,
            depthSegment,
            heightSegment
          ],
          /* tuple */[
            5,
            depthSegment,
            heightSegment
          ]
        ];
}

function _generateAllFaces(configDataMap) {
  var match = _getConfig(configDataMap);
  var faceDataTuple = _buildFaceData(match[0], match[1], match[2]);
  return ArraySystem$WonderCommonlib.reduceOneParam((function (pointsTuple, directionDataTuple) {
                return _generateFace(directionDataTuple, faceDataTuple, pointsTuple);
              }), /* tuple */[
              ArraySystem$WonderCommonlib.createEmpty(/* () */0),
              ArraySystem$WonderCommonlib.createEmpty(/* () */0)
            ], _buildAllFaceDirectionDataTupleArr(match[3], match[4], match[5]));
}

function _computeData(index, state) {
  var match = GeometryConfigDataCommon$Wonderjs.getConfigData(index, state);
  if (match) {
    var match$1 = _generateAllFaces(match[0]);
    return /* record */[
            /* vertices */match$1[0],
            /* indices */match$1[1]
          ];
  } else {
    return ExceptionHandleSystem$Wonderjs.throwMessage("configData should exist");
  }
}

function create(state) {
  var match = GeometryCreateCommon$Wonderjs.create(state);
  var index = match[1];
  var state$1 = match[0];
  SparseMapSystem$WonderCommonlib.set(index, _computeData, GeometryGetStateDataCommon$Wonderjs.getGeometryData(state$1)[/* computeDataFuncMap */3]);
  return /* tuple */[
          state$1,
          index
        ];
}

export {
  _getConfig                         ,
  _buildFaceData                     ,
  _getLerpData                       ,
  _generateVertex                    ,
  _generateIndex                     ,
  _generateFace                      ,
  _buildAllFaceDirectionDataTupleArr ,
  _generateAllFaces                  ,
  _computeData                       ,
  create                             ,
  
}
/* ArraySystem-WonderCommonlib Not a pure module */
