// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Caml_array                          from "../../../../../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Caml_int32                          from "../../../../../../../node_modules/bs-platform/lib/es6/caml_int32.js";
import * as Vector3System$Wonderjs              from "../../../../structure/Vector3System.js";
import * as ArraySystem$WonderCommonlib         from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArraySystem.js";
import * as GeometryCreateCommon$Wonderjs       from "./GeometryCreateCommon.js";
import * as HashMapSystem$WonderCommonlib       from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/HashMapSystem.js";
import * as ExceptionHandleSystem$Wonderjs      from "../../../../exception/ExceptionHandleSystem.js";
import * as SparseMapSystem$WonderCommonlib     from "../../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapSystem.js";
import * as GeometryConfigDataCommon$Wonderjs   from "./GeometryConfigDataCommon.js";
import * as GeometryGetStateDataCommon$Wonderjs from "./GeometryGetStateDataCommon.js";

function _computeData(index, state) {
  var match = GeometryConfigDataCommon$Wonderjs.getConfigData(index, state);
  if (match) {
    var configDataMap = match[0];
    var width = HashMapSystem$WonderCommonlib.unsafeGet("width", configDataMap);
    var height = HashMapSystem$WonderCommonlib.unsafeGet("height", configDataMap);
    var depth = HashMapSystem$WonderCommonlib.unsafeGet("depth", configDataMap);
    var widthSegment = HashMapSystem$WonderCommonlib.unsafeGet("widthSegment", configDataMap);
    var heightSegment = HashMapSystem$WonderCommonlib.unsafeGet("heightSegment", configDataMap);
    var depthSegment = HashMapSystem$WonderCommonlib.unsafeGet("depthSegment", configDataMap);
    var vertices = ArraySystem$WonderCommonlib.createEmpty(/* () */0);
    var indices = ArraySystem$WonderCommonlib.createEmpty(/* () */0);
    var faceAxes = /* array */[
      /* int array */[
        0,
        1,
        3
      ],
      /* int array */[
        4,
        5,
        7
      ],
      /* int array */[
        3,
        2,
        6
      ],
      /* int array */[
        1,
        0,
        4
      ],
      /* int array */[
        1,
        4,
        2
      ],
      /* int array */[
        5,
        0,
        6
      ]
    ];
    var corners = /* array */[
      /* tuple */[
        -width,
        -height,
        depth
      ],
      /* tuple */[
        width,
        -height,
        depth
      ],
      /* tuple */[
        width,
        height,
        depth
      ],
      /* tuple */[
        -width,
        height,
        depth
      ],
      /* tuple */[
        width,
        -height,
        -depth
      ],
      /* tuple */[
        -width,
        -height,
        -depth
      ],
      /* tuple */[
        -width,
        height,
        -depth
      ],
      /* tuple */[
        width,
        height,
        -depth
      ]
    ];
    var _generateFace = function (side, uSegment, vSegment) {
      var offset = vertices.length / 3 | 0;
      for(var i = 0; i <= uSegment; ++i){
        for(var j = 0; j <= vSegment; ++j){
          var temp1 = Vector3System$Wonderjs.lerp(Caml_array.caml_array_get(corners, Caml_array.caml_array_get(Caml_array.caml_array_get(faceAxes, side), 0)), Caml_array.caml_array_get(corners, Caml_array.caml_array_get(Caml_array.caml_array_get(faceAxes, side), 1)), i / uSegment);
          var temp2 = Vector3System$Wonderjs.lerp(Caml_array.caml_array_get(corners, Caml_array.caml_array_get(Caml_array.caml_array_get(faceAxes, side), 0)), Caml_array.caml_array_get(corners, Caml_array.caml_array_get(Caml_array.caml_array_get(faceAxes, side), 2)), j / vSegment);
          var temp3 = Vector3System$Wonderjs.sub(/* Float */0, temp2, Caml_array.caml_array_get(corners, Caml_array.caml_array_get(Caml_array.caml_array_get(faceAxes, side), 0)));
          var match = Vector3System$Wonderjs.add(/* Float */0, temp1, temp3);
          vertices.push(match[0], match[1], match[2]);
          if (i < uSegment && j < vSegment) {
            indices.push((offset + j | 0) + Caml_int32.imul(i, uSegment + 1 | 0) | 0, (offset + j | 0) + Caml_int32.imul(i + 1 | 0, uSegment + 1 | 0) | 0, ((offset + j | 0) + Caml_int32.imul(i, uSegment + 1 | 0) | 0) + 1 | 0, (offset + j | 0) + Caml_int32.imul(i + 1 | 0, uSegment + 1 | 0) | 0, ((offset + j | 0) + Caml_int32.imul(i + 1 | 0, uSegment + 1 | 0) | 0) + 1 | 0, ((offset + j | 0) + Caml_int32.imul(i, uSegment + 1 | 0) | 0) + 1 | 0);
          }
          
        }
      }
      return /* () */0;
    };
    _generateFace(0, widthSegment | 0, heightSegment | 0);
    _generateFace(1, widthSegment | 0, heightSegment | 0);
    _generateFace(2, widthSegment | 0, depthSegment | 0);
    _generateFace(3, widthSegment | 0, depthSegment | 0);
    _generateFace(4, depthSegment | 0, heightSegment | 0);
    _generateFace(5, depthSegment | 0, heightSegment | 0);
    return /* record */[
            /* vertices */vertices,
            /* indices */indices
          ];
  } else {
    return ExceptionHandleSystem$Wonderjs.throwMessage("configData should exist");
  }
}

function create(state) {
  var match = GeometryCreateCommon$Wonderjs.create(state);
  var index = match[1];
  var state$1 = match[0];
  SparseMapSystem$WonderCommonlib.set(index, _computeData, GeometryGetStateDataCommon$Wonderjs.getGeometryData(state$1)[/* computeDataFuncMap */3]);
  return /* tuple */[
          state$1,
          index
        ];
}

export {
  _computeData ,
  create       ,
  
}
/* ArraySystem-WonderCommonlib Not a pure module */
