// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Contract$Wonderjs                    from "../../../definition/Contract.js";
import * as LogUtils$WonderCommonlib             from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/logUtils.js";
import * as SparseMapSystem$WonderCommonlib      from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapSystem.js";
import * as ShaderRestoreFromStateUtils$Wonderjs from "../utils/ShaderRestoreFromStateUtils.js";

function _getProgramData(state) {
  return state[/* programData */17];
}

function createProgram(gl) {
  return gl.createProgram();
}

function _compileShader(gl, glslSource, shader) {
  gl.shaderSource(shader, glslSource);
  gl.compileShader(shader);
  return Contract$Wonderjs.ensureCheck((function (shader) {
                return Contract$Wonderjs.test("judge shader parameter", (function () {
                              if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
                                LogUtils$WonderCommonlib.log(gl.getShaderInfoLog(shader));
                                return LogUtils$WonderCommonlib.log("source:\n            " + (String(glslSource) + ""));
                              } else {
                                return 0;
                              }
                            }));
              }), shader);
}

function _linkProgram(program, gl) {
  return Contract$Wonderjs.ensureCheck((function () {
                return Contract$Wonderjs.testWithMessageFunc((function () {
                              var message = gl.getProgramInfoLog(program);
                              return "link program error:" + (String(message) + "");
                            }), (function () {
                              return Contract$Wonderjs.assertJsTrue(gl.getProgramParameter(program, gl.LINK_STATUS));
                            }));
              }), (gl.linkProgram(program), /* () */0));
}

function initShader(vsSource, fsSource, gl, program) {
  var vs = _compileShader(gl, vsSource, gl.createShader(gl.VERTEX_SHADER));
  var fs = _compileShader(gl, fsSource, gl.createShader(gl.FRAGMENT_SHADER));
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.bindAttribLocation(program, 0, "a_position");
  _linkProgram(program, gl);
  gl.deleteShader(vs);
  gl.deleteShader(fs);
  return program;
}

function getProgram(shaderIndex, state) {
  return SparseMapSystem$WonderCommonlib.get(shaderIndex, state[/* programData */17][/* programMap */0]);
}

function unsafeGetProgram(shaderIndex, state) {
  return Contract$Wonderjs.ensureCheck((function () {
                return Contract$Wonderjs.test("program should exist", (function () {
                              return Contract$Wonderjs.assertExist(SparseMapSystem$WonderCommonlib.get(shaderIndex, state[/* programData */17][/* programMap */0]));
                            }));
              }), SparseMapSystem$WonderCommonlib.unsafeGet(shaderIndex, state[/* programData */17][/* programMap */0]));
}

function registerProgram(shaderIndex, state, program) {
  SparseMapSystem$WonderCommonlib.set(shaderIndex, program, state[/* programData */17][/* programMap */0]);
  return program;
}

function use(gl, program, state) {
  var data = state[/* programData */17];
  var match = data[/* lastUsedProgram */1];
  var exit = 0;
  if (match) {
    if (program === match[0]) {
      return state;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    data[/* lastUsedProgram */1] = /* Some */[program];
    gl.useProgram(program);
    return state;
  }
  
}

function deepCopyStateForRestore(state) {
  return state;
}

function restore(intersectShaderIndexDataArray, currentState, targetState) {
  var match = currentState[/* programData */17];
  var newrecord = targetState.slice();
  newrecord[/* programData */17] = /* record */[
    /* programMap */ShaderRestoreFromStateUtils$Wonderjs.getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* programMap */0]),
    /* lastUsedProgram : None */0
  ];
  return newrecord;
}

export {
  _getProgramData         ,
  createProgram           ,
  _compileShader          ,
  _linkProgram            ,
  initShader              ,
  getProgram              ,
  unsafeGetProgram        ,
  registerProgram         ,
  use                     ,
  deepCopyStateForRestore ,
  restore                 ,
  
}
/* ShaderRestoreFromStateUtils-Wonderjs Not a pure module */
