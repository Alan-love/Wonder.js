// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Log$WonderLog                        from "../../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog                   from "../../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as StateData$Wonderjs                   from "../../../core/StateData.js";
import * as SparseMapSystem$WonderCommonlib      from "../../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapSystem.js";
import * as ShaderRestoreFromStateUtils$Wonderjs from "../utils/ShaderRestoreFromStateUtils.js";

function _getProgramData(state) {
  return state[/* programData */17];
}

function createProgram(gl) {
  return gl.createProgram();
}

function _compileShader(gl, glslSource, shader) {
  gl.shaderSource(shader, glslSource);
  gl.compileShader(shader);
  Log$WonderLog.debugWithFunc((function () {
          var match = +(gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false);
          if (match !== 0) {
            var message = gl.getShaderInfoLog(shader);
            var partial_arg = "" + (String(message) + "");
            Log$WonderLog.debug((function (param) {
                    return Log$WonderLog.buildDebugMessage("shader info log", partial_arg, param);
                  }), StateData$Wonderjs.stateData[/* isDebug */1]);
            var partial_arg$1 = "" + (String(glslSource) + "");
            return Log$WonderLog.debug((function (param) {
                          return Log$WonderLog.buildDebugMessage("glsl source", partial_arg$1, param);
                        }), StateData$Wonderjs.stateData[/* isDebug */1]);
          } else {
            return /* () */0;
          }
        }), StateData$Wonderjs.stateData[/* isDebug */1]);
  return shader;
}

function _linkProgram(program, gl) {
  gl.linkProgram(program);
  Log$WonderLog.debugWithFunc((function () {
          var match = +(gl.getProgramParameter(program, gl.LINK_STATUS) === false);
          if (match !== 0) {
            var message = gl.getProgramInfoLog(program);
            return Log$WonderLog.fatal(Log$WonderLog.buildFatalMessage("link program error", "" + (String(message) + ""), "", "", ""));
          } else {
            return /* () */0;
          }
        }), StateData$Wonderjs.stateData[/* isDebug */1]);
  return /* () */0;
}

function initShader(vsSource, fsSource, gl, program) {
  var vs = _compileShader(gl, vsSource, gl.createShader(gl.VERTEX_SHADER));
  var fs = _compileShader(gl, fsSource, gl.createShader(gl.FRAGMENT_SHADER));
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.bindAttribLocation(program, 0, "a_position");
  _linkProgram(program, gl);
  gl.deleteShader(vs);
  gl.deleteShader(fs);
  return program;
}

function getProgram(shaderIndex, state) {
  return SparseMapSystem$WonderCommonlib.get(shaderIndex, state[/* programData */17][/* programMap */0]);
}

function unsafeGetProgram(shaderIndex, state) {
  return Contract$WonderLog.ensureCheck((function (program) {
                return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("program exist", "not"), (function () {
                              return Contract$WonderLog.assertNullableExist(program);
                            }));
              }), StateData$Wonderjs.stateData[/* isDebug */1], SparseMapSystem$WonderCommonlib.unsafeGet(shaderIndex, state[/* programData */17][/* programMap */0]));
}

function registerProgram(shaderIndex, state, program) {
  SparseMapSystem$WonderCommonlib.set(shaderIndex, program, state[/* programData */17][/* programMap */0]);
  return program;
}

function use(gl, program, state) {
  var data = state[/* programData */17];
  var match = data[/* lastUsedProgram */1];
  var exit = 0;
  if (match) {
    if (program === match[0]) {
      return state;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    data[/* lastUsedProgram */1] = /* Some */[program];
    gl.useProgram(program);
    return state;
  }
  
}

function deepCopyStateForRestore(state) {
  return state;
}

function restore(intersectShaderIndexDataArray, currentState, targetState) {
  var match = currentState[/* programData */17];
  var newrecord = targetState.slice();
  newrecord[/* programData */17] = /* record */[
    /* programMap */ShaderRestoreFromStateUtils$Wonderjs.getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* programMap */0]),
    /* lastUsedProgram : None */0
  ];
  return newrecord;
}

export {
  _getProgramData         ,
  createProgram           ,
  _compileShader          ,
  _linkProgram            ,
  initShader              ,
  getProgram              ,
  unsafeGetProgram        ,
  registerProgram         ,
  use                     ,
  deepCopyStateForRestore ,
  restore                 ,
  
}
/* Log-WonderLog Not a pure module */
