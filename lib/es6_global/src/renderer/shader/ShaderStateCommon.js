// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Contract$Wonderjs             from "../../definition/Contract.js";
import * as ArraySystem$Wonderjs          from "../../structure/ArraySystem.js";
import * as HashMapSystem$Wonderjs        from "../../structure/HashMapSystem.js";
import * as HashMapSystem$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/HashMapSystem.js";

function getShaderData(state) {
  return state[/* shaderData */16];
}

function getGLSLData(state) {
  return state[/* shaderData */16][/* glslData */2];
}

function deepCopyStateForRestore(state) {
  var match = state[/* shaderData */16];
  var index = match[/* index */0];
  var shaderIndexMap = match[/* shaderIndexMap */1];
  var match$1 = state[/* shaderData */16][/* glslData */2];
  var precision = match$1[/* precision */0];
  var newrecord = state.slice();
  newrecord[/* shaderData */16] = /* record */[
    /* index */index,
    /* shaderIndexMap */shaderIndexMap,
    /* glslData : record */[/* precision */precision]
  ];
  return newrecord;
}

function getIntersectShaderIndexDataArray(currentState, targetState) {
  var match = currentState[/* shaderData */16];
  var currentShaderIndexMap = match[/* shaderIndexMap */1];
  var match$1 = targetState[/* shaderData */16];
  var targetShaderIndexMap = match$1[/* shaderIndexMap */1];
  return ArraySystem$Wonderjs.reduceOneParam((function (dataArr, param) {
                dataArr.push(/* tuple */[
                      HashMapSystem$WonderCommonlib.unsafeGet(param[0], currentShaderIndexMap),
                      param[1]
                    ]);
                return dataArr;
              }), /* array */[], HashMapSystem$Wonderjs.entries(targetShaderIndexMap).filter((function (param) {
                    return HashMapSystem$WonderCommonlib.has(param[0], currentShaderIndexMap);
                  })));
}

function _getIntersectShaderIndexMap(currentShaderIndexMap, targetShaderIndexMap) {
  var intersectShaderIndexDataArr = HashMapSystem$Wonderjs.entries(targetShaderIndexMap).filter((function (param) {
          return HashMapSystem$WonderCommonlib.has(param[0], currentShaderIndexMap);
        }));
  return /* tuple */[
          intersectShaderIndexDataArr.length,
          ArraySystem$Wonderjs.reduceOneParam((function (shaderMap, param) {
                  return HashMapSystem$WonderCommonlib.set(param[0], param[1], shaderMap);
                }), HashMapSystem$WonderCommonlib.createEmpty(/* () */0), intersectShaderIndexDataArr)
        ];
}

function restore(currentState, targetState) {
  Contract$Wonderjs.requireCheck((function () {
          return Contract$Wonderjs.test("currentState and targetState ->shaderData->glslData->precision should be the same", (function () {
                        var match = currentState[/* shaderData */16][/* glslData */2][/* precision */0];
                        var match$1 = targetState[/* shaderData */16][/* glslData */2][/* precision */0];
                        if (match) {
                          if (match$1) {
                            return Contract$Wonderjs.Operators[/* ==^ */2](match[0], match$1[0]);
                          } else {
                            return Contract$Wonderjs.assertFail(/* () */0);
                          }
                        } else if (match$1) {
                          return Contract$Wonderjs.assertFail(/* () */0);
                        } else {
                          return Contract$Wonderjs.assertPass(/* () */0);
                        }
                      }));
        }));
  var match = currentState[/* shaderData */16];
  var currentShaderIndexMap = match[/* shaderIndexMap */1];
  var targetShaderData = targetState[/* shaderData */16];
  var targetShaderIndexMap = targetShaderData[/* shaderIndexMap */1];
  var match$1 = _getIntersectShaderIndexMap(currentShaderIndexMap, targetShaderIndexMap);
  var newrecord = targetState.slice();
  newrecord[/* shaderData */16] = /* record */[
    /* index */match$1[0],
    /* shaderIndexMap */match$1[1],
    /* glslData */targetShaderData[/* glslData */2]
  ];
  return newrecord;
}

export {
  getShaderData                    ,
  getGLSLData                      ,
  deepCopyStateForRestore          ,
  getIntersectShaderIndexDataArray ,
  _getIntersectShaderIndexMap      ,
  restore                          ,
  
}
/* ArraySystem-Wonderjs Not a pure module */
