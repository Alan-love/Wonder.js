// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Log$WonderLog                 from "../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog            from "../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as StateData$Wonderjs            from "../../core/StateData.js";
import * as HashMapSystem$Wonderjs        from "../../structure/HashMapSystem.js";
import * as ArraySystem$WonderCommonlib   from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/ArraySystem.js";
import * as HashMapSystem$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/HashMapSystem.js";

function getShaderData(state) {
  return state[/* shaderData */16];
}

function getGLSLData(state) {
  return state[/* shaderData */16][/* glslData */2];
}

function deepCopyStateForRestore(state) {
  var match = state[/* shaderData */16];
  var index = match[/* index */0];
  var shaderIndexMap = match[/* shaderIndexMap */1];
  var match$1 = state[/* shaderData */16][/* glslData */2];
  var precision = match$1[/* precision */0];
  var newrecord = state.slice();
  newrecord[/* shaderData */16] = /* record */[
    /* index */index,
    /* shaderIndexMap */shaderIndexMap,
    /* glslData : record */[/* precision */precision]
  ];
  return newrecord;
}

function getIntersectShaderIndexDataArray(currentState, targetState) {
  var match = currentState[/* shaderData */16];
  var currentShaderIndexMap = match[/* shaderIndexMap */1];
  var match$1 = targetState[/* shaderData */16];
  var targetShaderIndexMap = match$1[/* shaderIndexMap */1];
  return ArraySystem$WonderCommonlib.reduceOneParam((function (dataArr, param) {
                dataArr.push(/* tuple */[
                      HashMapSystem$WonderCommonlib.unsafeGet(param[0], currentShaderIndexMap),
                      param[1]
                    ]);
                return dataArr;
              }), /* array */[], HashMapSystem$Wonderjs.entries(targetShaderIndexMap).filter((function (param) {
                    return HashMapSystem$WonderCommonlib.has(param[0], currentShaderIndexMap);
                  })));
}

function _getIntersectShaderIndexMap(currentShaderIndexMap, targetShaderIndexMap) {
  var intersectShaderIndexDataArr = HashMapSystem$Wonderjs.entries(targetShaderIndexMap).filter((function (param) {
          return HashMapSystem$WonderCommonlib.has(param[0], currentShaderIndexMap);
        }));
  return /* tuple */[
          intersectShaderIndexDataArr.length,
          ArraySystem$WonderCommonlib.reduceOneParam((function (shaderMap, param) {
                  return HashMapSystem$WonderCommonlib.set(param[0], param[1], shaderMap);
                }), HashMapSystem$WonderCommonlib.createEmpty(/* () */0), intersectShaderIndexDataArr)
        ];
}

function restore(currentState, targetState) {
  Contract$WonderLog.requireCheck((function () {
          var currentPrecision = currentState[/* shaderData */16][/* glslData */2][/* precision */0];
          var targetPrecision = targetState[/* shaderData */16][/* glslData */2][/* precision */0];
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("currentState->shaderData->glslData->precision and targetState ->shaderData->glslData->precision be the same", "not"), (function () {
                        if (currentPrecision) {
                          if (targetPrecision) {
                            return Contract$WonderLog.Operators[/* ==^ */2](currentPrecision[0], targetPrecision[0]);
                          } else {
                            return Contract$WonderLog.assertFail(/* () */0);
                          }
                        } else if (targetPrecision) {
                          return Contract$WonderLog.assertFail(/* () */0);
                        } else {
                          return Contract$WonderLog.assertPass(/* () */0);
                        }
                      }));
        }), StateData$Wonderjs.stateData[/* isDebug */1]);
  var match = currentState[/* shaderData */16];
  var currentShaderIndexMap = match[/* shaderIndexMap */1];
  var targetShaderData = targetState[/* shaderData */16];
  var targetShaderIndexMap = targetShaderData[/* shaderIndexMap */1];
  var match$1 = _getIntersectShaderIndexMap(currentShaderIndexMap, targetShaderIndexMap);
  var newrecord = targetState.slice();
  newrecord[/* shaderData */16] = /* record */[
    /* index */match$1[0],
    /* shaderIndexMap */match$1[1],
    /* glslData */targetShaderData[/* glslData */2]
  ];
  return newrecord;
}

export {
  getShaderData                    ,
  getGLSLData                      ,
  deepCopyStateForRestore          ,
  getIntersectShaderIndexDataArray ,
  _getIntersectShaderIndexMap      ,
  restore                          ,
  
}
/* Log-WonderLog Not a pure module */
