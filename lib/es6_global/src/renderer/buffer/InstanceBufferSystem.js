// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Contract$Wonderjs               from "../../definition/Contract.js";
import * as TypeArrayPoolSystem$Wonderjs    from "../../structure/pool/TypeArrayPoolSystem.js";
import * as VboBufferPoolCommon$Wonderjs    from "./VboBufferPoolCommon.js";
import * as SparseMapSystem$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapSystem.js";

function _getDefaultCapacity() {
  return 4096;
}

function createBuffer(gl, capacity, state) {
  var buffer = VboBufferPoolCommon$Wonderjs.getInstanceBuffer(gl, state);
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, capacity, gl.DYNAMIC_DRAW);
  return buffer;
}

function _getFloat32InstanceArraySize(capacity) {
  Contract$Wonderjs.requireCheck((function () {
          return Contract$Wonderjs.test("capacity should be a multiplier of 4", (function () {
                        return Contract$Wonderjs.Operators[/* = */0](capacity % 4, 0);
                      }));
        }));
  return capacity / 4 | 0;
}

function _createModelMatrixFloat32Array(capacity) {
  return new Float32Array(_getFloat32InstanceArraySize(capacity));
}

function _getCapacity(sourceInstance, capacityMap) {
  var match = SparseMapSystem$WonderCommonlib.get(sourceInstance, capacityMap);
  if (match) {
    return match[0];
  } else {
    return 4096;
  }
}

function _setCapacity(sourceInstance, capacity, capacityMap) {
  SparseMapSystem$WonderCommonlib.set(sourceInstance, capacity, capacityMap);
  return capacityMap;
}

function getOrCreateBuffer(gl, sourceInstance, capacityMap, bufferMap, state) {
  var match = SparseMapSystem$WonderCommonlib.get(sourceInstance, bufferMap);
  if (match) {
    return match[0];
  } else {
    var buffer = createBuffer(gl, _getCapacity(sourceInstance, capacityMap), state);
    SparseMapSystem$WonderCommonlib.set(sourceInstance, buffer, bufferMap);
    return buffer;
  }
}

function getOrCreateModelMatrixFloat32Array(sourceInstance, capacityMap, modelMatrixFloat32ArrayMap, state) {
  var capacity = _getCapacity(sourceInstance, capacityMap);
  var match = SparseMapSystem$WonderCommonlib.get(sourceInstance, modelMatrixFloat32ArrayMap);
  if (match) {
    return match[0];
  } else {
    var match$1 = TypeArrayPoolSystem$Wonderjs.getFloat32TypeArrayFromPool(capacity, state);
    if (match$1) {
      return match$1[0];
    } else {
      var typeArr = new Float32Array(_getFloat32InstanceArraySize(capacity));
      SparseMapSystem$WonderCommonlib.set(sourceInstance, typeArr, modelMatrixFloat32ArrayMap);
      return typeArr;
    }
  }
}

function setCapacityAndUpdateBufferAndTypeArray(gl, sourceInstance, capacity, buffer, modelMatrixFloat32Array, bufferMap, modelMatrixFloat32ArrayMap, capacityMap, state) {
  var currentCapacity = _getCapacity(sourceInstance, capacityMap);
  var needIncreaseCapacity = /* false */0;
  while(currentCapacity < capacity) {
    currentCapacity = (currentCapacity << 1);
    needIncreaseCapacity = /* true */1;
  };
  if (needIncreaseCapacity) {
    _setCapacity(sourceInstance, currentCapacity, capacityMap);
    gl.deleteBuffer(buffer);
    var buffer$1 = createBuffer(gl, currentCapacity, state);
    SparseMapSystem$WonderCommonlib.set(sourceInstance, buffer$1, bufferMap);
    var modelMatrixFloat32Array$1 = new Float32Array(_getFloat32InstanceArraySize(currentCapacity));
    SparseMapSystem$WonderCommonlib.set(sourceInstance, modelMatrixFloat32Array$1, modelMatrixFloat32ArrayMap);
    return /* tuple */[
            buffer$1,
            modelMatrixFloat32Array$1
          ];
  } else {
    return /* tuple */[
            buffer,
            modelMatrixFloat32Array
          ];
  }
}

function updateData(gl, data, buffer) {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);
  return buffer;
}

export {
  _getDefaultCapacity                    ,
  createBuffer                           ,
  _getFloat32InstanceArraySize           ,
  _createModelMatrixFloat32Array         ,
  _getCapacity                           ,
  _setCapacity                           ,
  getOrCreateBuffer                      ,
  getOrCreateModelMatrixFloat32Array     ,
  setCapacityAndUpdateBufferAndTypeArray ,
  updateData                             ,
  
}
/* TypeArrayPoolSystem-Wonderjs Not a pure module */
