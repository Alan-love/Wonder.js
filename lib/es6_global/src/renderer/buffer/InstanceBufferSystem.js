// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Log$WonderLog                   from "../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as Contract$WonderLog              from "../../../../../node_modules/wonder-log/lib/es6_global/src/Contract.js";
import * as StateData$Wonderjs              from "../../core/StateData.js";
import * as TypeArrayPoolSystem$Wonderjs    from "../../structure/pool/TypeArrayPoolSystem.js";
import * as VboBufferPoolCommon$Wonderjs    from "./VboBufferPoolCommon.js";
import * as SparseMapSystem$WonderCommonlib from "../../../../../node_modules/wonder-commonlib/lib/es6_global/src/SparseMapSystem.js";

function _getDefaultCapacity() {
  return 4096;
}

function createBuffer(gl, capacity, state) {
  var buffer = VboBufferPoolCommon$Wonderjs.getInstanceBuffer(gl, state);
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, capacity, gl.DYNAMIC_DRAW);
  return buffer;
}

function _getFloat32InstanceArraySize(capacity) {
  Contract$WonderLog.requireCheck((function () {
          return Contract$WonderLog.test(Log$WonderLog.buildAssertMessage("capacity should be a multiplier of 4", "is " + (String(capacity) + "")), (function () {
                        return Contract$WonderLog.Operators[/* = */0](capacity % 4, 0);
                      }));
        }), StateData$Wonderjs.stateData[/* isDebug */1]);
  return capacity / 4 | 0;
}

function _createModelMatrixFloat32Array(capacity) {
  return new Float32Array(_getFloat32InstanceArraySize(capacity));
}

function _getCapacity(sourceInstance, capacityMap) {
  var match = SparseMapSystem$WonderCommonlib.get(sourceInstance, capacityMap);
  if (match) {
    return match[0];
  } else {
    return 4096;
  }
}

function _setCapacity(sourceInstance, capacity, capacityMap) {
  SparseMapSystem$WonderCommonlib.set(sourceInstance, capacity, capacityMap);
  return capacityMap;
}

function getOrCreateBuffer(gl, sourceInstance, param, state) {
  var bufferMap = param[1];
  var match = SparseMapSystem$WonderCommonlib.get(sourceInstance, bufferMap);
  if (match) {
    return match[0];
  } else {
    var buffer = createBuffer(gl, _getCapacity(sourceInstance, param[0]), state);
    SparseMapSystem$WonderCommonlib.set(sourceInstance, buffer, bufferMap);
    return buffer;
  }
}

function getOrCreateModelMatrixFloat32Array(sourceInstance, capacityMap, modelMatrixFloat32ArrayMap, state) {
  var capacity = _getCapacity(sourceInstance, capacityMap);
  var match = SparseMapSystem$WonderCommonlib.get(sourceInstance, modelMatrixFloat32ArrayMap);
  if (match) {
    return match[0];
  } else {
    var match$1 = TypeArrayPoolSystem$Wonderjs.getFloat32TypeArrayFromPool(capacity, state);
    if (match$1) {
      return match$1[0];
    } else {
      var typeArr = new Float32Array(_getFloat32InstanceArraySize(capacity));
      SparseMapSystem$WonderCommonlib.set(sourceInstance, typeArr, modelMatrixFloat32ArrayMap);
      return typeArr;
    }
  }
}

function setCapacityAndUpdateBufferTypeArray(param, param$1, param$2, state) {
  var capacityMap = param$2[2];
  var buffer = param$1[0];
  var capacity = param[2];
  var sourceInstance = param[1];
  var gl = param[0];
  var currentCapacity = _getCapacity(sourceInstance, capacityMap);
  var needIncreaseCapacity = /* false */0;
  while(currentCapacity < capacity) {
    currentCapacity = (currentCapacity << 1);
    needIncreaseCapacity = /* true */1;
  };
  if (needIncreaseCapacity) {
    _setCapacity(sourceInstance, currentCapacity, capacityMap);
    gl.deleteBuffer(buffer);
    var buffer$1 = createBuffer(gl, currentCapacity, state);
    SparseMapSystem$WonderCommonlib.set(sourceInstance, buffer$1, param$2[0]);
    var modelMatrixFloat32Array = new Float32Array(_getFloat32InstanceArraySize(currentCapacity));
    SparseMapSystem$WonderCommonlib.set(sourceInstance, modelMatrixFloat32Array, param$2[1]);
    return /* tuple */[
            buffer$1,
            modelMatrixFloat32Array
          ];
  } else {
    return /* tuple */[
            buffer,
            param$1[1]
          ];
  }
}

function updateData(gl, data, buffer) {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);
  return buffer;
}

export {
  _getDefaultCapacity                 ,
  createBuffer                        ,
  _getFloat32InstanceArraySize        ,
  _createModelMatrixFloat32Array      ,
  _getCapacity                        ,
  _setCapacity                        ,
  getOrCreateBuffer                   ,
  getOrCreateModelMatrixFloat32Array  ,
  setCapacityAndUpdateBufferTypeArray ,
  updateData                          ,
  
}
/* Log-WonderLog Not a pure module */
