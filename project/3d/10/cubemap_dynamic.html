<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>3d学习</title>
    <script src="../../bower_components/jquery/dist/jquery.js" type="text/javascript"></script>
    <!--<script src="../jsExtend.js" type="text/javascript"></script>-->
    <script src="../Scene.js" type="text/javascript"></script>
    <script src="../Matrix.js" type="text/javascript"></script>
    <script src="../Cubic.js" type="text/javascript"></script>
    <script src="../Sprite.js" type="text/javascript"></script>
    <script src="../Buffer.js" type="text/javascript"></script>
    <script src="../FrameBuffer.js" type="text/javascript"></script>
    <script src="../Loader.js" type="text/javascript"></script>
    <script src="../Program.js" type="text/javascript"></script>
    <script src="../Shader.js" type="text/javascript"></script>
    <script src="../Webgl.js" type="text/javascript"></script>
    <script src="../Texture.js" type="text/javascript"></script>
    <script src="../Camera.js" type="text/javascript"></script>
    <script src="../Rotate.js" type="text/javascript"></script>
    <script src="../Translate.js" type="text/javascript"></script>
    <script src="../Light.js" type="text/javascript"></script>
    <script src="../Material.js" type="text/javascript"></script>
    <script src="cubemap_dynamic.js" type="text/javascript"></script>

<body>
<canvas id="canvas" width="600" height="400"></canvas>

<script id="reflect-vs" type="x-shader/x-vertex">
//todo 统一这个shader和light shader，要么都在世界坐标系中，要么都在视图坐标系中！

attribute vec3 a_position;
attribute vec3 a_normal;

uniform mat4   u_mvpMatrix;
uniform mat4   u_mvMatrix;
uniform mat4   u_normalMatrix;
uniform mat4   u_mInverseCamera;

// Texture coordinate to fragment program
//smooth out vec3 vVaryingTexCoord;
varying vec3 v_texCoord;

void main(void)
{
// Normal in Eye Space
vec4 vEyeNormal = u_normalMatrix * vec4(a_normal, 1.0);

// Vertex position in Eye Space
vec4 vPos = vec4(a_position, 1.0);
vec4 vEyePos = normalize(u_mvMatrix * vPos);

// Get reflected vector
vec4 vCoords = reflect(-vEyePos, vEyeNormal);

// Rotate by flipped camera
//convert vCoords from eye coordinate to world coordinate
vCoords = u_mInverseCamera * vCoords;


v_texCoord= normalize(vCoords.xyz);

// Don't forget to transform the geometry!
gl_Position = u_mvpMatrix * vPos;
}
</script>


<script id="reflect-fs" type="x-shader/x-fragment">
precision mediump float;
uniform samplerCube u_sampler;
varying vec3 v_texCoord;

void main(void){
    gl_FragColor = textureCube(u_sampler, v_texCoord);
}
</script>



<script id="texture2D-light-vs" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec3 a_normal;

uniform mat4 u_mvpMatrix;
uniform mat4 u_mMatrix;
uniform mat4 u_normalMatrix;


varying vec3 v_normal;
varying vec3 v_position;
attribute vec2 a_texCoord;
varying vec2 v_texCoord;

void main(void){
    gl_Position = u_mvpMatrix * a_position;
    v_position = vec3(u_mMatrix * a_position);
    //v_normal = normalize(a_normal);
    v_normal = normalize(vec3(u_normalMatrix * vec4(a_normal, 1.0)));
    //v_normal = normalize(a_normal);
    v_texCoord = a_texCoord;
}
        </script>

<script id="texture2D-light-fs" type="x-shader/x-fragment">
precision mediump float;

////环境光属于场景属性，不属于Light类的属性，而且也不会衰减
//环境光属于场景属性，不属于Light类的属性（要衰减）

//平行光不衰减，只有点光源要衰减


struct PointLight {
    vec3 position;
    vec3 color;

    float range;
    float constant;
    float linear;
    float quadratic;

    float intensity;
};
//struct DirectionLight {
//    vec3 direction;
//    vec3 color;
//    float intensity;
//};

//struct不支持sampler2D类型
//struct Material{
//    uniform sampler2D diffuse;
//    uniform sampler2D specular;
//    float shininess;
//};
//uniform Material u_material;


   uniform float u_shininess;
    uniform sampler2D u_diffuseSampler;
    uniform sampler2D u_specularSampler;



#define NR_POINT_LIGHTS 2


uniform vec3 u_ambient;
//uniform DirectionLight u_directionLight;
uniform PointLight u_pointLights[NR_POINT_LIGHTS];


varying vec2 v_texCoord;





uniform vec3 u_viewPos;


varying vec3 v_position;
varying vec3 v_normal;


vec3 calcLight(vec3 lightDir, vec3 color, float intensity, float attenuation, vec3 normal, vec3 viewDir)
{
    float dotResultBetweenNormAndLight = dot(normal, lightDir);
    // Diffuse shading
    float diff = max(dotResultBetweenNormAndLight, 0.0);;

    // Specular shading
    float spec = 0.0;
    //背面（指立方体中与当前面对应的背面，而不是当前面的反面）没有当前面反射光
    if(dotResultBetweenNormAndLight < 0.0){
        spec = 0.0;
    }
    else{
        vec3 reflectDir = reflect(-lightDir, normal);
        spec = pow(max(dot(viewDir, reflectDir), 0.0), u_shininess);
    }

    // Combine results
    vec3 ambientColor = u_ambient * vec3(texture2D(u_diffuseSampler, v_texCoord));
    vec3 diffuseColor = color * diff * vec3(texture2D(u_diffuseSampler, v_texCoord));
    vec3 specularColor = color * spec * vec3(texture2D(u_specularSampler, v_texCoord));

    return intensity * attenuation * ( ambientColor + diffuseColor + specularColor);
    //return vec3(distance/ 256.0, ambientColor, 0.0);
}

//// Calculates the color when using a directional light.
//vec3 calcDirectionLight(DirectionLight light, vec3 normal, vec3 viewDir)
//{
//    vec3 lightDir = normalize(light.direction);
//    float attenuation = 1.0;
//
//    return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);
//}

// Calculates the color when using a point light.
vec3 calcPointLight(PointLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - v_position);

    // Attenuation
    float distance = length(light.position - v_position);

    float attenuation = 0.0;
    if(distance < light.range)
    {
        attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));
    }

    return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);
}


void main(void){
    vec3 norm = normalize(v_normal);
    vec3 viewDir = normalize(u_viewPos - v_position);
    //vec3 totalLight = calcDirectionLight(u_directionLight, norm, viewDir);
    vec3 totalLight = vec3(0.0, 0.0, 0.0);

   for(int i = 0; i < NR_POINT_LIGHTS; i++){
        totalLight += calcPointLight(u_pointLights[i], norm, viewDir);
   }

    gl_FragColor = vec4(totalLight, 1.0);
}
</script>




<script id="texture2D-vs" type="x-shader/x-vertex">
attribute vec4 a_position;
uniform mat4 u_mvpMatrix;
attribute vec2 a_texCoord;
varying vec2 v_texCoord;

void main(void){
    gl_Position = u_mvpMatrix * a_position;
    v_texCoord = a_texCoord;
}
        </script>

<script id="texture2D-fs" type="x-shader/x-fragment">
precision mediump float;

uniform sampler2D u_sampler;
varying vec2 v_texCoord;

void main(void){
    gl_FragColor = texture2D(u_sampler, v_texCoord);
}
</script>

<script id="skyBox-vs" type="x-shader/x-vertex">
attribute vec4 a_position;
uniform mat4 u_mvpMatrix;
attribute vec3 a_texCoord;
varying vec3 v_texCoord;

void main(void){
    gl_Position = u_mvpMatrix * a_position;
    v_texCoord = a_texCoord;
}
        </script>

<script id="skyBox-fs" type="x-shader/x-fragment">
precision mediump float;

uniform samplerCube u_sampler;
varying vec3 v_texCoord;

void main(void){
    gl_FragColor = textureCube(u_sampler, v_texCoord);
}
</script>
</body>
</html>