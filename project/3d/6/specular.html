<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>3d学习</title>
    <script src="../../bower_components/jquery/dist/jquery.js" type="text/javascript"></script>
    <script src="../jsExtend.js" type="text/javascript"></script>

    <script src="../Matrix.js" type="text/javascript"></script>
    <script src="../Cubic.js" type="text/javascript"></script>
    <script src="../Sprite.js" type="text/javascript"></script>
    <script src="../Buffer.js" type="text/javascript"></script>
    <script src="../FrameBuffer.js" type="text/javascript"></script>
    <script src="../Loader.js" type="text/javascript"></script>
    <script src="../Program.js" type="text/javascript"></script>
    <script src="../Shader.js" type="text/javascript"></script>
    <script src="../Webgl.js" type="text/javascript"></script>
    <script src="../Texture.js" type="text/javascript"></script>
    <script src="../Camera.js" type="text/javascript"></script>
    <script src="../Rotate.js" type="text/javascript"></script>
    <script src="../Light.js" type="text/javascript"></script>
    <script src="../Material.js" type="text/javascript"></script>

    <script src="specular.js" type="text/javascript"></script>
</head>
<body>
<canvas id="canvas" width="600" height="400"></canvas>

<script id="vs" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec3 a_normal;

uniform mat4 u_mvpMatrix;
uniform mat4 u_mMatrix;
uniform mat4 u_normalMatrix;


varying vec3 v_normal;
varying vec3 v_position;
attribute vec2 a_texCoord;
varying vec2 v_texCoord;

void main(void){
    gl_Position = u_mvpMatrix * a_position;
    v_position = vec3(u_mMatrix * a_position);
    //v_normal = normalize(a_normal);
    v_normal = normalize(vec3(u_normalMatrix * vec4(a_normal, 1.0)));
    //v_normal = normalize(a_normal);
    v_texCoord = a_texCoord;
}
        </script>

<script id="fs" type="x-shader/x-fragment">
precision mediump float;

struct PointLight {
    vec3 position;
    vec3 color;
    float intensity;
};
struct DirectionLight {
    vec3 direction;
    vec3 color;
    float intensity;
};

//struct不支持sampler2D类型
//struct Material{
//    uniform sampler2D diffuse;
//    uniform sampler2D specular;
//    float shininess;
//};
//uniform Material u_material;


   uniform float u_shininess;
    uniform sampler2D u_diffuseSampler;
    uniform sampler2D u_specularSampler;




uniform vec3 u_ambient;
uniform DirectionLight u_directionLight;
uniform PointLight u_pointLight;



varying vec2 v_texCoord;





uniform vec3 u_viewPos;


varying vec3 v_position;
varying vec3 v_normal;

// Calculates the color when using a directional light.
vec3 calcDirectionLight(DirectionLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(light.direction);
    //vec3 lightDir = vec3(0.0, 0.0, 1.0);
    float dotResultBetwwenNormAndLight = dot(normal, lightDir);
    // Diffuse shading
    float diff = max(dotResultBetwwenNormAndLight, 0.0)* light.intensity;;
    // Specular shading
    float spec = 0.0;
    //背面（指立方体中与当前面对应的背面，而不是当前面的反面）没有当前面反射光
    if(dotResultBetwwenNormAndLight < 0.0){
        spec = 0.0;
    }
    else{
        vec3 reflectDir = reflect(-lightDir, normal);
        spec = pow(max(dot(viewDir, reflectDir), 0.0), u_shininess) * light.intensity;
    }
    // Combine results
    vec3 ambient = u_ambient * vec3(texture2D(u_diffuseSampler, v_texCoord));
    vec3 diffuse = light.color * diff * vec3(texture2D(u_diffuseSampler, v_texCoord));
    vec3 specular = light.color * spec * vec3(texture2D(u_specularSampler, v_texCoord));
    return (ambient + diffuse + specular);
}
vec3 calcPointLight(PointLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - v_position);
    // Diffuse shading
    float diff = max(dot(normal, lightDir), 0.0)* light.intensity;;
    // Specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_shininess) * light.intensity;
    // Combine results
    vec3 ambient = u_ambient * vec3(texture2D(u_diffuseSampler, v_texCoord));
    vec3 diffuse = light.color * diff * vec3(texture2D(u_diffuseSampler, v_texCoord));
    vec3 specular = light.color * spec * vec3(texture2D(u_specularSampler, v_texCoord));
    return (ambient + diffuse + specular);
    //return vec3(0.0, 0.0, 0.0);
}
void main(void){
    vec3 norm = normalize(v_normal);
    //vec3 norm = vec3(0.0, 0.0, 1.0);
    vec3 viewDir = normalize(u_viewPos - v_position);
    vec3 totalLight = calcDirectionLight(u_directionLight, norm, viewDir);
    totalLight = totalLight + calcPointLight(u_pointLight, norm, viewDir);
    gl_FragColor = vec4(totalLight, 1.0);
}
</script>
</body>
</html>

